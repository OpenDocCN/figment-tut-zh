# 介绍

> 原文:[https://github . com/fig ment-networks/learn-tutorials/blob/master/cosmos/build-a-name service-app . MD](https://github.com/figment-networks/learn-tutorials/blob/master/cosmos/build-a-nameservice-app.md)

[**原文教程可以在 Cosmos SDK 文档这里找到**](https://tutorials.cosmos.network/nameservice/tutorial/00-intro.html#) 。

在本教程中，您将构建一个功能性的 [Cosmos SDK](https://github.com/cosmos/cosmos-sdk/) 应用程序，并在此过程中学习 SDK 的基本概念和结构。这个例子将展示在 Cosmos SDK 的基础上**从零开始**构建你自己的区块链是多么的快速和容易。

在本教程结束时，您将拥有一个功能性的`nameservice`应用程序，一个字符串到其他字符串的映射(`map[string]string`)。这类似于[名币](https://namecoin.org/)、 [ENS](https://ens.domains/) ，或者[握手](https://handshake.org/)，都是对传统 DNS 系统(`map[domain]zonefile`)的建模。用户将能够购买未使用的名称，或出售/交易他们的名字。

本教程项目的所有最终源代码都在这个目录中(并且可以编译)。然而，最好是手动跟随并尝试自己构建项目！

# 要求

*   [`golang` > 1.13.0](https://golang.org/doc/install) 安装完毕
*   Github 账户和 [Github CLI](https://hub.github.com/) 或 [Github 桌面(需要 64 位)](https://help.github.com/en/desktop/getting-started-with-github-desktop/installing-github-desktop)
*   渴望创造自己的区块链！
*   将使用[脚手架工具](https://github.com/cosmos/scaffold)来完成本教程。克隆 repo 并使用`git clone git@github.com:cosmos/scaffold.git && cd scaffold && make`安装。查看回购协议以获得更详细的说明。

# 入门指南

通过本教程的学习，您将创建组成您的应用程序的以下文件:

```
./nameservice
├── Makefile
├── Makefile.ledger
├── app.go
├── cmd
│   ├── nscli
│   │   └── main.go
│   └── nsd
│       └── main.go
├── go.mod
├── go.sum
└── x
    └── nameservice
        ├── alias.go
        ├── client
        │   ├── cli
        │   │   ├── query.go
        │   │   └── tx.go
        │   └── rest
        │       ├── query.go
        │       ├── rest.go
        │       └── tx.go
        ├── genesis.go
        ├── handler.go
        ├── keeper
        │   ├── keeper.go
        │   └── querier.go
        ├── types
        │   ├── codec.go
        │   ├── errors.go
        │   ├── expected_keepers.go
        │   ├── key.go
        │   ├── msgs.go
        │   ├── querier.go
        │   └── types.go
        └── module.go 
```

跟着走！第一步描述应用程序的设计。

# 应用目标

您正在构建的应用程序的目标是让用户购买名称，并设置这些名称解析的值。给定名称的所有者将是当前的最高出价者。在本节中，您将了解这些简单的需求如何转化为应用程序设计。

区块链应用只是一个[复制的确定性状态机](https://en.wikipedia.org/wiki/State_machine_replication)。作为一名开发人员，你只需要定义状态机(即什么状态，一个起始状态和触发状态转换的消息)，而 [*Tendermint*](https://docs.tendermint.com/master/introduction/) 将为你处理网络上的复制。

> Tendermint 是一个与应用无关的引擎，负责处理区块链的*网络*和*共识*层。实际上，这意味着 Tendermint 负责传播和排序事务字节。Tendermint Core 依靠一种同名的拜占庭容错(BFT)算法来就交易顺序达成共识。更多关于 Tendermint 的信息，点击[这里](https://tendermint.com/docs/introduction/introduction.html)。

Cosmos SDK 旨在帮助你构建状态机。SDK 是一个**模块化框架**，这意味着应用程序是通过聚合一组可互操作的模块构建的。每个模块都包含自己的消息/事务处理器，而 SDK 负责将每个消息路由到各自的模块。

以下是名称服务应用程序需要的模块:

*   这个模块定义了账户和费用，并为你的应用程序的其他部分提供了对这些功能的访问。
*   `bank`:该模块使应用程序能够创建和管理令牌和令牌余额。
*   这个模块使应用程序能够拥有人们可以委托的验证器。
*   这个模块给出了一个在验证者和授权者之间被动分配奖励的函数方法。
*   这个模块不鼓励那些在网络中有价值的人。验证器。
*   `supply`:该模块保存供应链的总供应量。
*   `nameservice`:该模块尚不存在！它将处理您正在构建的`nameservice`应用程序的核心逻辑。它是构建应用程序时必须使用的主要软件。

现在，看看应用程序的两个主要部分:状态**和消息**类型**。**

# 状态

状态代表给定时刻的应用程序。它说明了每个帐户拥有多少令牌，每个名称的所有者和价格，以及每个名称解析为什么值。

令牌和帐户的状态是由`auth`和`bank`模块定义的，这意味着您现在不必关心它。您需要做的是定义与您的`nameservice`模块特别相关的状态部分。

在 SDK 中，所有东西都存储在一个名为`multistore`的存储中。在这个多商店中可以创建任意数量的键/值商店(在 Cosmos SDK 中称为 [`KVStores`](https://godoc.org/github.com/cosmos/cosmos-sdk/types#KVStore) )。对于这个应用程序，我们将使用一个商店将`name`映射到其相应的`whois`，一个保存名称的值、所有者和价格的结构。

# 信息

消息包含在事务中。它们触发状态转换。每个模块都定义了一个消息列表以及如何处理它们。以下是为名称服务应用程序实现所需功能所需的消息:

*   `MsgSetName`:此消息允许域名所有者为给定的域名设置一个值。
*   这个消息允许帐户购买一个名字并成为它的所有者。
    *   当有人购买一个域名时，他们需要向该域名的前所有人支付高于前所有人的价格。如果一个名字还没有以前的所有者，他们必须烧掉`MinPrice`数量。

当一个事务(包含在一个块中)到达一个 Tendermint 节点时，它通过 [ABCI](https://github.com/tendermint/tendermint/tree/master/abci) 被传递给应用程序，并被解码以获得消息。然后，消息被发送到适当的模块，并根据`Handler`中定义的逻辑进行处理。如果状态需要更新，`Handler`调用`Keeper`来执行更新。在本教程的下一步中，您将了解更多关于这些概念的内容。

既然您已经从高层次的角度决定了您的应用程序如何运行，那么是时候开始实现它了。

# 创建您的应用程序

为了创建新的应用程序，我们将使用由 scaffold 工具提供的 lvl-1 应用程序。

您可以用您的 Github 用户名填写`user`,用您正在创建的 repo 的名称填写`repo`。

```
scaffold app lvl-1 [user] [repo] [flags]

cd [repo] 
```

在`app.go`中，定义了应用程序在收到交易时做什么。但是首先，它需要能够以正确的顺序接收事务。这就是 [Tendermint 共识引擎](https://github.com/tendermint/tendermint)的作用。

每个模块和导入包的 godocs 链接:

*   [`log`](https://godoc.org/github.com/tendermint/tendermint/libs/log) :嫩薄荷的伐木工。
*   [`auth`](https://godoc.org/github.com/cosmos/cosmos-sdk/x/auth) :宇宙 SDK 的`auth`模块。
*   [`dbm`](https://godoc.org/github.com/tendermint/tm-db) :使用 Tendermint 数据库的代码。
*   [`baseapp`](https://godoc.org/github.com/cosmos/cosmos-sdk/baseapp) :见下图

这里有几个包是`tendermint`包。Tendermint 通过一个名为 [ABCI](https://docs.tendermint.com/master/spec/abci/) 的接口将交易从网络传递给应用程序。如果您查看正在构建的区块链节点的体系结构，它看起来如下所示:

```
+---------------------+
|                     |
|     Application     |
|                     |
+--------+---+--------+
         ^   |
         |   | ABCI
         |   v
+--------+---+--------+
|                     |
|                     |
|     Tendermint      |
|                     |
|                     |
+---------------------+ 
```

幸运的是，您不必实现 ABCI 接口。Cosmos SDK 以 [`baseapp`](https://godoc.org/github.com/cosmos/cosmos-sdk/baseapp) 的形式提供了一个样板实现。

下面是`baseapp`做的事情:

*   解码从 Tendermint 共识引擎接收的交易。
*   从事务中提取消息，并进行基本的健全性检查。
*   将消息路由到适当的模块，以便对其进行处理。注意`baseapp`不知道您想要使用的具体模块。在`app.go`中声明这样的模块是你的工作，你将在本教程的后面看到。`baseapp`只实现可以应用于任何模块的核心路由逻辑。
*   提交如果 ABCI 消息是 [`DeliverTx`](https://docs.tendermint.com/master/spec/abci/abci.html#delivertx) ( [`CheckTx`](https://docs.tendermint.com/master/spec/abci/abci.html#checktx) 变化不持久)。
*   帮助设置 [`Beginblock`](https://docs.tendermint.com/master/spec/abci/abci.html#beginblock) 和 [`Endblock`](https://docs.tendermint.com/master/spec/abci/abci.html#endblock) ，这两条消息使您能够定义在每个程序块开始和结束时执行的逻辑。在实践中，每个模块都实现了自己的`BeginBlock`和`EndBlock`子逻辑，应用程序的作用是将所有内容聚合在一起(*注意:您不会在应用程序*中使用这些消息)。
*   帮助初始化您的状态。
*   帮助设置查询。

现在您需要将`appName` & `NewApp`类型重命名为您的应用程序的名称。这种情况下你可以使用`nameservice` & `NameServiceApp`。这个类型将嵌入`baseapp`(在 Go 中的嵌入类似于其他语言中的继承)，这意味着它可以访问所有`baseapp`的方法。

太好了！现在，您已经启动了应用程序。目前你有一个工作的区块链，但我们将在本教程中定制它。

不知道您想在应用程序中使用的路线或用户交互。您的应用程序的主要作用是定义这些路线。另一个作用是定义初始状态。这两种情况都要求您向应用程序中添加模块。

正如您在[应用程序设计](https://tutorials.cosmos.network/nameservice/tutorial/app-design.html)部分看到的，您的名称服务需要几个模块:`auth`、`bank`、`staking`、`distribution`、`slashing`和`nameservice`。前五个已经存在，但不是最后一个！`nameservice`模块将定义你的状态机的主体。下一步是构建它。

为了完成您的应用程序，您需要包含模块。继续并开始构建您的名称服务模块。你稍后会回到`app.go`。

# 类型

我们要做的第一件事是使用下面的命令，用脚手架工具在`/x/`文件夹中创建一个模块:

在本教程中，我们将模块命名为`nameservice`

```
cd x/

scaffold module [user] [repo] nameservice 
```

**T2`types.go`**

现在我们可以继续创建一个模块。首先在`./x/nameservice/types`文件夹中创建文件`types.go`，该文件将保存模块的海关类型。

## Whois

每个名字都有三段相关的数据。

*   值-名称解析的值。这只是一个任意的字符串，但是将来您可以修改它，要求它符合特定的格式，例如 IP 地址、DNS 区域文件或区块链地址。
*   所有者-名称的当前所有者的地址
*   价格-购买该名称需要支付的价格

要启动 SDK 模块，请在`./x/nameservice/types/types.go`文件中定义您的`nameservice.Whois`结构:

```
package types

import (
	"fmt"
	"strings"

	sdk "github.com/cosmos/cosmos-sdk/types"
)

// MinNamePrice is Initial Starting Price for a name that was never previously owned
var MinNamePrice = sdk.Coins{sdk.NewInt64Coin("nametoken", 1)}

// Whois is a struct that contains all the metadata of a name
type Whois struct {
	Value string         `json:"value"`
	Owner sdk.AccAddress `json:"owner"`
	Price sdk.Coins      `json:"price"`
}

// NewWhois returns a new Whois with the minprice as the price
func NewWhois() Whois {
	return Whois{
		Price: MinNamePrice,
	}
}

// implement fmt.Stringer
func (w Whois) String() string {
	return strings.TrimSpace(fmt.Sprintf(`Owner: %s
Value: %s
Price: %s`, w.Owner, w.Value, w.Price))
}
```

正如在[设计文档](https://tutorials.cosmos.network/nameservice/tutorial/app-design.html)中提到的，如果一个名字还没有所有者，我们想用一些 MinPrice 来初始化它。

## 钥匙

首先导航到 types 文件夹中的`key.go`文件。在`key.go`文件中，您将会看到在整个模块创建过程中使用的密钥已经被创建。

定义将在整个应用程序中使用的键有助于编写 [DRY](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) 代码。

```
package types

const (
	// ModuleName is the name of the module
	ModuleName = "nameservice"

	// StoreKey to be used when creating the KVStore
	StoreKey = ModuleName

	// RouterKey is the module name router key
	RouterKey = ModuleName

	// QuerierRoute to be used for querierer msgs
	QuerierRoute = ModuleName
)
```

## 错误

首先导航到类型文件夹中的`errors.go`文件。在您的`errors.go`文件中，定义您的模块定制的错误及其代码。

```
package types

import (
	sdkerrors "github.com/cosmos/cosmos-sdk/types/errors"
)

var (
	ErrNameDoesNotExist = sdkerrors.Register(ModuleName, 1, "name does not exist")
)
```

您还必须添加在错误处理时将被调用的相应方法。例如，假设我们试图删除一个不在商店中的名字。在这种情况下，应该会抛出一个错误，因为该名称不存在。

我们将在后面的教程中看到这个方法被调用的地方。

现在我们继续为模块编写保持器。

## 预期保管人

接下来在`/types`目录下创建一个名为`expected_keepers.go`的文件。在这个文件中，我们将定义我们期望其他模块拥有什么。

例如，在名称服务模块中，我们将使用银行模块来促进双方之间的转账。为此，我们将依赖银行模块中的两个函数。

*   `SubtractCoins(ctx sdk.Context, addr sdk.AccAddress, amt sdk.Coins) (sdk.Coins, error)`

*   `SendCoins(ctx sdk.Context, fromAddr sdk.AccAddress, toAddr sdk.AccAddress, amt sdk.Coins) error`

您可以在下面看到该文件的结构:

```
package types

import (
	sdk "github.com/cosmos/cosmos-sdk/types"
)

// When a module wishes to interact with an otehr module it is good practice to define what it will use
// as an interface so the module can not use things that are not permitted.
type BankKeeper interface {
	SubtractCoins(ctx sdk.Context, addr sdk.AccAddress, amt sdk.Coins) (sdk.Coins, error)
	SendCoins(ctx sdk.Context, fromAddr sdk.AccAddress, toAddr sdk.AccAddress, amt sdk.Coins) error
}
```

# 冥王

Cosmos SDK 模块的主要核心是一个叫做`Keeper`的部分。它处理与存储的交互，具有对跨模块交互的其他保持器的引用，并包含模块的大多数核心功能。

## 保持器结构

要启动您的 SDK 模块，请在`./x/nameservice/keeper/keeper.go`文件中定义您的`nameservice.Keeper`。在这个生成的文件中定义了一些额外的项目，我们这次不会涉及，因此，我们将从清除`keeper.go`文件开始，以支持本教程。

```
package keeper

import (
	"github.com/cosmos/cosmos-sdk/codec"
	sdk "github.com/cosmos/cosmos-sdk/types"
	"github.com/cosmos/sdk-tutorials/nameservice/x/nameservice/types"
)

// Keeper maintains the link to data storage and exposes getter/setter methods for the various parts of the state machine
type Keeper struct {
	CoinKeeper types.BankKeeper

	storeKey  sdk.StoreKey // Unexposed key to access store from sdk.Context

	cdc *codec.Codec // The wire codec for binary encoding/decoding.
}
```

关于上述代码的几点注意事项:

*   您的应用程序的两个`cosmos-sdk`包和`types`被导入:
    *   [`codec`](https://godoc.org/github.com/cosmos/cosmos-sdk/codec)—`codec`提供了处理 Cosmos 编码格式的工具，[氨基](https://github.com/tendermint/go-amino)。
    *   [`types`(as sdk)](https://godoc.org/github.com/cosmos/cosmos-sdk/types)——这包含了整个 SDK 中常用的类型。
    *   `types` -它包含您在上一节定义的`BankKeeper`。
*   `Keeper`结构。这款门将有几个关键部分:
    *   `types.BankKeeper` -这是您在上一节定义的使用`bank`模块的接口。包含它允许这个模块中的代码从`bank`模块中调用函数。SDK 使用一种[对象功能](https://en.wikipedia.org/wiki/Object-capability_model)方法来访问应用程序状态的各个部分。这是为了允许开发人员采用最小权限方法，限制有故障或恶意模块的能力，使其不会影响它不需要访问的状态部分。
    *   [`*codec.Codec`](https://godoc.org/github.com/cosmos/cosmos-sdk/codec#Codec)——这是一个指针，指向 Amino 用来编码和解码二进制结构的编解码器。
    *   [`sdk.StoreKey`](https://godoc.org/github.com/cosmos/cosmos-sdk/types#StoreKey)——这是一个存储键，用来访问一个`sdk.KVStore`，它保存你的应用程序的状态:名字所指向的 Whois 结构(即`map[name]Whois`)。

## Getters 和 Setters

现在是时候添加通过`Keeper`与商店交互的方法了。首先，添加一个函数来设置给定名称解析的 Whois:

```
// Sets the entire Whois metadata struct for a name
func (k Keeper) SetWhois(ctx sdk.Context, name string, whois types.Whois) {
	if whois.Owner.Empty() {
		return
	}
	store := ctx.KVStore(k.storeKey)
	store.Set([]byte(name), k.cdc.MustMarshalBinaryBare(whois))
}
```

在这个方法中，首先使用来自`Keeper`的`storeKey`获取`map[name]Whois`的存储对象。

> *注意*:该功能使用 [`sdk.Context`](https://godoc.org/github.com/cosmos/cosmos-sdk/types#Context) 。这个对象拥有访问状态的一些重要部分的函数，比如`blockHeight`和`chainID`。

接下来，使用其`.Set([]byte, []byte)`方法将`<name, whois>`对插入到存储中。由于商店只接受`[]byte`，我们使用名为 Amino 的 Cosmos SDK 编码库将`Whois`结构编组到`[]byte`以插入到商店中。

如果一个`Whois`的所有者字段为空，我们不向存储中写入任何内容，因为所有存在的名字都必须有一个所有者。

接下来，添加一个方法来解析名称(即查找`name`的`Whois`):

```
// Gets the entire Whois metadata struct for a name
func (k Keeper) GetWhois(ctx sdk.Context, name string) types.Whois {
	store := ctx.KVStore(k.storeKey)
	if !k.IsNamePresent(ctx, name) {
		return types.NewWhois()
	}
	bz := store.Get([]byte(name))
	var whois types.Whois
	k.cdc.MustUnmarshalBinaryBare(bz, &whois)
	return whois
}
```

这里，像在`SetName`方法中一样，首先使用`storeKey`访问商店。接下来，不要在商店键上使用`Set`方法，而是使用`.Get([]byte) []byte`方法。作为函数的参数，传递 key，也就是被转换为`[]byte`的`name`字符串，以`[]byte`的形式返回结果。我们再次使用 Amino，但这次是将字节片解组回一个`Whois`结构，然后我们返回这个结构。

如果名称当前不存在于存储中，它返回一个新的`Whois`，其中初始化了 minimumPrice。

接下来，添加一个删除名称的方法:

```
// Deletes the entire Whois metadata struct for a name
func (k Keeper) DeleteWhois(ctx sdk.Context, name string) {
	store := ctx.KVStore(k.storeKey)
	store.Delete([]byte(name))
}
```

这里，像在`SetName`方法中一样，首先使用`storeKey`访问商店。接下来，我们使用`.Delete([]byte)`方法从商店中删除这个名字。由于商店只取`[]byte`，所以`name`字符串在作为函数参数传递的同时被强制转换为`[]byte`。

现在，我们添加根据名称从存储中获取特定参数的函数。然而，我们没有重写存储 getters 和 setters，而是重用了`GetWhois`和`SetWhois`函数。例如，要设置一个字段，首先我们获取整个`Whois`数据，更新我们的特定字段，并将新版本放回存储中。

```
// ResolveName - returns the string that the name resolves to
func (k Keeper) ResolveName(ctx sdk.Context, name string) string {
	return k.GetWhois(ctx, name).Value
}

// SetName - sets the value string that a name resolves to
func (k Keeper) SetName(ctx sdk.Context, name string, value string) {
	whois := k.GetWhois(ctx, name)
	whois.Value = value
	k.SetWhois(ctx, name, whois)
}

// HasOwner - returns whether or not the name already has an owner
func (k Keeper) HasOwner(ctx sdk.Context, name string) bool {
	return !k.GetWhois(ctx, name).Owner.Empty()
}

// GetOwner - gets the current owner of a name
func (k Keeper) GetOwner(ctx sdk.Context, name string) sdk.AccAddress {
	return k.GetWhois(ctx, name).Owner
}

// SetOwner - sets the current owner of a name
func (k Keeper) SetOwner(ctx sdk.Context, name string, owner sdk.AccAddress) {
	whois := k.GetWhois(ctx, name)
	whois.Owner = owner
	k.SetWhois(ctx, name, whois)
}

// GetPrice - gets the current price of a name
func (k Keeper) GetPrice(ctx sdk.Context, name string) sdk.Coins {
	return k.GetWhois(ctx, name).Price
}

// SetPrice - sets the current price of a name
func (k Keeper) SetPrice(ctx sdk.Context, name string, price sdk.Coins) {
	whois := k.GetWhois(ctx, name)
	whois.Price = price
	k.SetWhois(ctx, name, whois)
}

// Check if the name is present in the store or not
func (k Keeper) IsNamePresent(ctx sdk.Context, name string) bool {
	store := ctx.KVStore(k.storeKey)
	return store.Has([]byte(name))
}
```

SDK 还包括一个名为`sdk.Iterator`的特性，它返回一个迭代器，遍历存储中特定位置的所有`<Key, Value>`对。我们将添加一个函数来获取存储中所有名字的迭代器。

```
// Get an iterator over all names in which the keys are the names and the values are the whois
func (k Keeper) GetNamesIterator(ctx sdk.Context) sdk.Iterator {
	store := ctx.KVStore(k.storeKey)
	return sdk.KVStorePrefixIterator(store, []byte{})
}
```

`./x/nameservice/keeper/keeper.go`文件中需要的最后一段代码是`Keeper`的构造函数:

```
// NewKeeper creates new instances of the nameservice Keeper
func NewKeeper(cdc *codec.Codec, storeKey sdk.StoreKey, coinKeeper types.BankKeeper) Keeper {
	return Keeper{
		cdc:        cdc,
		storeKey:   storeKey,
		CoinKeeper: coinKeeper,
	}
}
```

接下来，是时候使用`Msgs`和`Handlers`来描述用户如何与你的新店互动了。

# 消息和处理程序

既然已经有了`Keeper`设置，是时候构建`Msgs`和`Handlers`了，它们实际上允许用户购买名称并为它们设置值。

**T2`Msgs`**

`Msgs`触发状态转换。`Msgs`被包裹在 [`Txs`](https://github.com/cosmos/cosmos-sdk/blob/master/types/tx_msg.go#L34-L41) 中，客户端提交给网络。Cosmos SDK 将`Msgs`从`Txs`中打包和解包，这意味着，作为一名应用开发者，你只需要定义`Msgs`。`Msgs`必须满足以下接口(我们将在下一节实现所有这些接口):

```
// Transactions messages must fulfill the Msg
type Msg interface {
	// Return the message type.
	// Must be alphanumeric or empty.
	Type() string

	// Returns a human-readable string for the message, intended for utilization
	// within tags
	Route() string

	// ValidateBasic does a simple validation check that
	// doesn't require access to any other information.
	ValidateBasic() Error

	// Get the canonical byte representation of the Msg.
	GetSignBytes() []byte

	// Signers returns the addrs of signers that must sign.
	// CONTRACT: All signatures must be present to be valid.
	// CONTRACT: Returns addrs in some deterministic order.
	GetSigners() []AccAddress
}

	// Transactions messages must fulfill the Msg type 
	Msg interface { 
	// Return the message type. 
	// Must be alphanumeric or empty. 
	Type() string 
	// Returns a human-readable string for the message, intended for utilization
	// within tags 
	Route() string 
	// ValidateBasic does a simple validation check that 
	// doesn't require access to any other information. 
	ValidateBasic() Error 
	// Get the canonical byte representation of the Msg. 
	GetSignBytes() []byte 
	// Signers returns the addrs of signers that must sign. 
	// CONTRACT: All signatures must be present to be valid. 
	// CONTRACT: Returns addrs in some deterministic order. 
	GetSigners() []AccAddress 
}
```

**T2`Handlers`**

`Handlers`定义收到给定的`Msg`时需要采取的行动(哪些商店需要更新，如何更新，以及在什么条件下更新)。

在这个模块中，用户可以发送三种类型的`Msgs`来与应用程序状态进行交互: [`SetName`](https://tutorials.cosmos.network/nameservice/tutorial/set-name.html) 、 [`BuyName`](https://tutorials.cosmos.network/nameservice/tutorial/buy-name.html) 和 [`DeleteName`](https://tutorials.cosmos.network/nameservice/tutorial/delete-name.html) 。他们每个人都有一个关联的`Handler`。

现在你对`Msgs`和`Handlers`有了更好的理解，你可以开始构建你的第一条消息:`SetName`

## 集合名称

**T2`MsgSetName`**

SDK `Msgs`的命名约定是`Msg{ .Action }`。第一个要实现的动作是`SetName`，所以我们称它为`MsgSetName`。这个`Msg`允许名称的所有者在解析器中设置该名称的返回值。首先在名为`./x/nameservice/types/msgs.go`的文件中定义`MsgSetName`:

```
package types

import (
	sdk "github.com/cosmos/cosmos-sdk/types"
)

const RouterKey = ModuleName // this was defined in your key.go file

// MsgSetName defines a SetName message
type MsgSetName struct {
	Name  string         `json:"name"`
	Value string         `json:"value"`
	Owner sdk.AccAddress `json:"owner"`
}

// NewMsgSetName is a constructor function for MsgSetName
func NewMsgSetName(name string, value string, owner sdk.AccAddress) MsgSetName {
	return MsgSetName{
		Name:  name,
		Value: value,
		Owner: owner,
	}
}
```

`MsgSetName`具有设置名称值所需的三个属性:

*   `name` -试图设定的名称。
*   `value` -这个名字意味着什么。
*   `owner`——那个名字的主人。

接下来，实现`Msg`接口:

```
// Route should return the name of the module
func (msg MsgSetName) Route() string { return RouterKey }

// Type should return the action
func (msg MsgSetName) Type() string { return "set_name" }
```

SDK 使用上述函数将`Msgs`路由到适当的模块进行处理。他们还将人类可读的名称添加到用于索引的数据库标签中。

```
// ValidateBasic runs stateless checks on the message
func (msg MsgSetName) ValidateBasic() error {
	if msg.Owner.Empty() {
		return sdkerrors.Wrap(sdkerrors.ErrInvalidAddress, msg.Owner.String())
	}
	if len(msg.Name) == 0 || len(msg.Value) == 0 {
		return sdkerrors.Wrap(sdkerrors.ErrUnknownRequest, "Name and/or Value cannot be empty")
	}
	return nil
}
```

`ValidateBasic`用于提供一些基本的**无状态**对`Msg`有效性的检查。在这种情况下，检查所有属性是否都为空。

```
// GetSignBytes encodes the message for signing
func (msg MsgSetName) GetSignBytes() []byte {
	return sdk.MustSortJSON(ModuleCdc.MustMarshalJSON(msg))
}
```

`GetSignBytes`定义了如何对`Msg`进行编码以进行签名。在大多数情况下，这意味着对排序的 JSON 进行封送。不应修改输出。

```
// GetSigners defines whose signature is required
func (msg MsgSetName) GetSigners() []sdk.AccAddress {
	return []sdk.AccAddress{msg.Owner}
}
```

`GetSigners`定义`Tx`上需要谁的签名才能有效。例如，在这种情况下，`MsgSetName`要求`Owner`在试图重置名称所指向的内容时签署事务。

**T2`Handler`**

既然已经指定了`MsgSetName`,下一步就是定义当收到这个消息时需要采取什么行动。这就是`handler`的作用。

在文件(`./x/nameservice/handler.go`)中以下面的代码开始:

```
package nameservice

import (
	"fmt"

	"github.com/cosmos/sdk-tutorials/nameservice/x/nameservice/types"

	sdk "github.com/cosmos/cosmos-sdk/types"
	sdkerrors "github.com/cosmos/cosmos-sdk/types/errors"
)

// NewHandler returns a handler for "nameservice" type messages.
func NewHandler(keeper Keeper) sdk.Handler {
	return func(ctx sdk.Context, msg sdk.Msg) (*sdk.Result, error) {
		switch msg := msg.(type) {
		case MsgSetName:
			return handleMsgSetName(ctx, keeper, msg)
		default:
			return nil, sdkerrors.Wrap(sdkerrors.ErrUnknownRequest, fmt.Sprintf("Unrecognized nameservice Msg type: %v", msg.Type()))
		}
	}
}
```

`NewHandler`本质上是一个子路由器，它将进入该模块的消息导向适当的处理器。目前只有一个`Msg` / `Handler`。

现在，您需要定义处理`handleMsgSetName`中的`MsgSetName`消息的实际逻辑:

> *注意*:SDK 中处理程序名称的命名约定是`handleMsg{ .Action }`

```
// Handle a message to set name
func handleMsgSetName(ctx sdk.Context, keeper Keeper, msg MsgSetName) (*sdk.Result, error) {
	if !msg.Owner.Equals(keeper.GetOwner(ctx, msg.Name)) { // Checks if the the msg sender is the same as the current owner
		return nil, sdkerrors.Wrap(sdkerrors.ErrUnauthorized, "Incorrect Owner") // If not, throw an error
	}
	keeper.SetName(ctx, msg.Name, msg.Value) // If so, set the name to the value specified in the msg.
	return &sdk.Result{}, nil                // return
}
```

在这个函数中，检查`Msg`发送者是否实际上是名称(`keeper.GetOwner`)的所有者。如果是这样，他们可以通过调用`Keeper`上的函数来设置名称。如果没有，抛出一个错误并返回给用户。

太好了，现在车主们可以`SetName` s！但是如果一个名字还没有主人呢？你的模块需要一个用户买名的方式！让我们定义一下`BuyName`消息。

## MsgBuyName

现在是时候定义购买名称的`Msg`并将其添加到`./x/nameservice/types/msgs.go`文件中了。这段代码与`SetName`非常相似:

```
// MsgBuyName defines the BuyName message
type MsgBuyName struct {
	Name  string         `json:"name"`
	Bid   sdk.Coins      `json:"bid"`
	Buyer sdk.AccAddress `json:"buyer"`
}

// NewMsgBuyName is the constructor function for MsgBuyName
func NewMsgBuyName(name string, bid sdk.Coins, buyer sdk.AccAddress) MsgBuyName {
	return MsgBuyName{
		Name:  name,
		Bid:   bid,
		Buyer: buyer,
	}
}

// Route should return the name of the module
func (msg MsgBuyName) Route() string { return RouterKey }

// Type should return the action
func (msg MsgBuyName) Type() string { return "buy_name" }

// ValidateBasic runs stateless checks on the message
func (msg MsgBuyName) ValidateBasic() error {
	if msg.Buyer.Empty() {
		return sdkerrors.Wrap(sdkerrors.ErrInvalidAddress, msg.Buyer.String())
	}
	if len(msg.Name) == 0 {
		return sdkerrors.Wrap(sdkerrors.ErrUnknownRequest, "Name cannot be empty")
	}
	if !msg.Bid.IsAllPositive() {
		return sdkerrors.ErrInsufficientFunds
	}
	return nil
}

// GetSignBytes encodes the message for signing
func (msg MsgBuyName) GetSignBytes() []byte {
	return sdk.MustSortJSON(ModuleCdc.MustMarshalJSON(msg))
}

// GetSigners defines whose signature is required
func (msg MsgBuyName) GetSigners() []sdk.AccAddress {
	return []sdk.AccAddress{msg.Buyer}
}
```

接下来，在`./x/nameservice/handler.go`文件中，将`MsgBuyName`处理程序添加到模块路由器:

```
// NewHandler returns a handler for "nameservice" type messages.
func NewHandler(keeper Keeper) sdk.Handler {
	return func(ctx sdk.Context, msg sdk.Msg) (*sdk.Result, error) {
		switch msg := msg.(type) {
		case MsgSetName:
			return handleMsgSetName(ctx, keeper, msg)
		case MsgBuyName:
			return handleMsgBuyName(ctx, keeper, msg)
		default:
			return nil, sdkerrors.Wrap(sdkerrors.ErrUnknownRequest, fmt.Sprintf("Unrecognized nameservice Msg type: %v", msg.Type()))
		}
	}
}
```

最后，定义`BuyName` `handler`函数，该函数执行由消息触发的状态转换。请记住，此时消息已经运行了它的`ValidateBasic`函数，所以会有一些输入验证。但是，`ValidateBasic`不能查询应用状态。依赖于网络状态(如账户余额)的验证逻辑应在`handler`功能中执行。

```
// Handle a message to buy name
func handleMsgBuyName(ctx sdk.Context, keeper Keeper, msg MsgBuyName) (*sdk.Result, error) {
	// Checks if the the bid price is greater than the price paid by the current owner
	if keeper.GetPrice(ctx, msg.Name).IsAllGT(msg.Bid) {
		return nil, sdkerrors.Wrap(sdkerrors.ErrInsufficientFunds, "Bid not high enough") // If not, throw an error
	}
	if keeper.HasOwner(ctx, msg.Name) {
		err := keeper.CoinKeeper.SendCoins(ctx, msg.Buyer, keeper.GetOwner(ctx, msg.Name), msg.Bid)
		if err != nil {
			return nil, err
		}
	} else {
		_, err := keeper.CoinKeeper.SubtractCoins(ctx, msg.Buyer, msg.Bid) // If so, deduct the Bid amount from the sender
		if err != nil {
			return nil, err
		}
	}
	keeper.SetOwner(ctx, msg.Name, msg.Buyer)
	keeper.SetPrice(ctx, msg.Name, msg.Bid)
	return &sdk.Result{}, nil
}
```

首先检查以确保出价高于当前价格。然后，检查该名称是否已经有了所有者。如果是这样的话，前所有者将从`Buyer`那里收到钱。

如果没有所有者，您的`nameservice`模块将从`Buyer`中“烧掉”(即发送到不可恢复的地址)硬币。

如果`SubtractCoins`或`SendCoins`返回一个非零错误，处理程序抛出一个错误，恢复状态转换。否则，使用前面在`Keeper`中定义的 getters 和 setters，处理程序将买方设置为新的所有者，并将新价格设置为当前出价。

> *注意*:这个处理程序使用`coinKeeper`中的函数来执行货币操作。如果您的应用程序正在执行货币操作，您可能想看看这个模块的 [godocs，看看它公开了什么功能。](https://godoc.org/github.com/cosmos/cosmos-sdk/x/bank#BaseKeeper)

太好了，现在车主们可以`BuyName` s！但是如果他们不想要这个名字了呢？你的模块需要一个让用户删除名字的方法！让我们定义一下`DeleteName`消息。

## MsgDeleteName

现在是时候定义用于删除名字的`Msg`并将其添加到`./x/nameservice/types/msgs.go`文件中了。这段代码与`SetName`非常相似:

```
// MsgDeleteName defines a DeleteName message
type MsgDeleteName struct {
	Name  string         `json:"name"`
	Owner sdk.AccAddress `json:"owner"`
}

// NewMsgDeleteName is a constructor function for MsgDeleteName
func NewMsgDeleteName(name string, owner sdk.AccAddress) MsgDeleteName {
	return MsgDeleteName{
		Name:  name,
		Owner: owner,
	}
}

// Route should return the name of the module
func (msg MsgDeleteName) Route() string { return RouterKey }

// Type should return the action
func (msg MsgDeleteName) Type() string { return "delete_name" }

// ValidateBasic runs stateless checks on the message
func (msg MsgDeleteName) ValidateBasic() error {
	if msg.Owner.Empty() {
		return sdkerrors.Wrap(sdkerrors.ErrInvalidAddress, msg.Owner.String())
	}
	if len(msg.Name) == 0 {
		return sdkerrors.Wrap(sdkerrors.ErrUnknownRequest, "Name cannot be empty")
	}
	return nil
}

// GetSignBytes encodes the message for signing
func (msg MsgDeleteName) GetSignBytes() []byte {
	return sdk.MustSortJSON(ModuleCdc.MustMarshalJSON(msg))
}

// GetSigners defines whose signature is required
func (msg MsgDeleteName) GetSigners() []sdk.AccAddress {
	return []sdk.AccAddress{msg.Owner}
}
```

接下来，在`./x/nameservice/handler.go`文件中，将`MsgDeleteName`处理程序添加到模块路由器:

```
// NewHandler returns a handler for "nameservice" type messages.
func NewHandler(keeper Keeper) sdk.Handler {
	return func(ctx sdk.Context, msg sdk.Msg) (*sdk.Result, error) {
		switch msg := msg.(type) {
		case MsgSetName:
			return handleMsgSetName(ctx, keeper, msg)
		case MsgBuyName:
			return handleMsgBuyName(ctx, keeper, msg)
		case MsgDeleteName:
			return handleMsgDeleteName(ctx, keeper, msg)
		default:
			return nil, sdkerrors.Wrap(sdkerrors.ErrUnknownRequest, fmt.Sprintf("Unrecognized nameservice Msg type: %v", msg.Type()))
		}
	}
}
```

最后，定义`DeleteName` `handler`函数，该函数执行由消息触发的状态转换。请记住，此时消息已经运行了它的`ValidateBasic`函数，所以会有一些输入验证。但是，`ValidateBasic`不能查询应用状态。依赖于网络状态(如账户余额)的验证逻辑应在`handler`功能中执行。

```
// Handle a message to delete name
func handleMsgDeleteName(ctx sdk.Context, keeper Keeper, msg MsgDeleteName) (*sdk.Result, error) {
	if !keeper.IsNamePresent(ctx, msg.Name) {
		return nil, sdkerrors.Wrap(types.ErrNameDoesNotExist, msg.Name)
	}
	if !msg.Owner.Equals(keeper.GetOwner(ctx, msg.Name)) {
		return nil, sdkerrors.Wrap(sdkerrors.ErrUnauthorized, "Incorrect Owner")
	}

	keeper.DeleteWhois(ctx, msg.Name)
	return &sdk.Result{}, nil
}
```

首先检查商店中当前是否存在该名称。如果没有，抛出一个错误并返回给用户。然后查看`Msg`发送者是否真的是这个名字的所有者(`keeper.GetOwner`)。如果是这样，他们可以通过调用`Keeper`上的函数来删除名字。如果没有，抛出一个错误并返回给用户。

既然已经定义了`Msgs`和`Handlers`，那么是时候学习如何使这些事务中的数据可供查询了。

# 问题

**查询类型**

首先导航到`./x/nameservice/types/querier.go`文件。这是您定义查询类型的地方。

```
package types

import "strings"

// QueryResResolve Queries Result Payload for a resolve query
type QueryResResolve struct {
	Value string `json:"value"`
}

// implement fmt.Stringer
func (r QueryResResolve) String() string {
	return r.Value
}

// QueryResNames Queries Result Payload for a names query
type QueryResNames []string

// implement fmt.Stringer
func (n QueryResNames) String() string {
	return strings.Join(n[:], "\n")
}
```

**切割机**

现在您可以导航到`./x/nameservice/keeper/querier.go`文件。这是定义应用程序状态用户能够进行哪些查询的地方。您的`nameservice`模块将公开三个查询:

*   `resolve`:这需要一个`name`并返回由`nameservice`存储的`value`。这类似于 DNS 查询。
*   `whois`:这需要一个`name`并返回名字的`price`、`value`和`owner`。用于计算你想买的名字的价格。
*   `name`:它没有参数，返回存储在`nameservice`中的所有名字。

您将看到`NewQuerier`已经被定义，这个函数作为查询这个模块的子路由器(类似于`NewHandler`函数)。注意，因为没有类似于查询`Msg`的接口，所以您需要手动定义 switch 语句用例(它们不能从查询`.Route()`函数中提取出来):

```
package keeper

import (
	"github.com/cosmos/cosmos-sdk/codec"
	"github.com/cosmos/sdk-tutorials/nameservice/x/nameservice/types"

	sdk "github.com/cosmos/cosmos-sdk/types"
	abci "github.com/tendermint/tendermint/abci/types"
)

// query endpoints supported by the nameservice Querier
const (
	QueryResolve = "resolve"
	QueryWhois   = "whois"
	QueryNames   = "names"
)

// NewQuerier is the module level router for state queries
func NewQuerier(keeper Keeper) sdk.Querier {
	return func(ctx sdk.Context, path []string, req abci.RequestQuery) (res []byte, err error) {
		switch path[0] {
		case QueryResolve:
			return queryResolve(ctx, path[1:], req, keeper)
		case QueryWhois:
			return queryWhois(ctx, path[1:], req, keeper)
		case QueryNames:
			return queryNames(ctx, req, keeper)
		default:
			return nil, sdkerrors.Wrap(sdkerrors.ErrUnknownRequest, "unknown nameservice query endpoint")
		}
	}
}
```

现在已经定义了路由器，接下来定义每个查询的输入和响应:

```
// nolint: unparam
func queryResolve(ctx sdk.Context, path []string, req abci.RequestQuery, keeper Keeper) ([]byte, error) {
	value := keeper.ResolveName(ctx, path[0])

	if value == "" {
		return []byte{}, sdkerrors.Wrap(sdkerrors.ErrUnknownRequest, "could not resolve name")
	}

	res, err := codec.MarshalJSONIndent(keeper.cdc, types.QueryResResolve{Value: value})
	if err != nil {
		return nil, sdkerrors.Wrap(sdkerrors.ErrJSONMarshal, err.Error())
	}

	return res, nil
}

// nolint: unparam
func queryWhois(ctx sdk.Context, path []string, req abci.RequestQuery, keeper Keeper) ([]byte, error) {
	whois := keeper.GetWhois(ctx, path[0])

	res, err := codec.MarshalJSONIndent(keeper.cdc, whois)
	if err != nil {
		return nil, sdkerrors.Wrap(sdkerrors.ErrJSONMarshal, err.Error())
	}

	return res, nil
}

func queryNames(ctx sdk.Context, req abci.RequestQuery, keeper Keeper) ([]byte, error) {
	var namesList types.QueryResNames

	iterator := keeper.GetNamesIterator(ctx)

	for ; iterator.Valid(); iterator.Next() {
		namesList = append(namesList, string(iterator.Key()))
	}

	res, err := codec.MarshalJSONIndent(keeper.cdc, namesList)
	if err != nil {
		return nil, sdkerrors.Wrap(sdkerrors.ErrJSONMarshal, err.Error())
	}

	return res, nil
}
```

上述代码的注释:

*   这里你的`Keeper`的 getters 和 setters 开始大量使用。当构建任何其他使用这个模块的应用程序时，您可能需要返回并定义更多的 getter/setter 来访问您需要的状态片段。
*   按照惯例，每个输出类型都应该是 JSON 可封送和可字符串化的(实现 Golang `fmt.Stringer`接口)。返回的字节应该是输出结果的 JSON 编码。
    *   所以对于`resolve`的输出类型，我们将解析字符串包装在一个名为`QueryResResolve`的结构中，这个结构既是 JSON 可编组的，又有一个`.String()`方法。
    *   对于 Whois 的输出，普通的 Whois 结构已经是 JSON 可编组的，但是我们需要在其上添加一个`.String()`方法。
    *   对于 names 查询的输出来说也是一样，一个`[]string`已经是本机可封送的，但是我们想在它上面添加一个`.String()`方法。
*   类型 Whois 未在`./x/nameservice/types/querier.go`文件中定义，因为它是在`./x/nameservice/types/types.go`文件中创建的。

既然您已经有了改变和查看模块状态的方法，是时候对它进行最后的润色了！定义您希望带到模块顶层的变量和类型。

# 别名

首先导航到`./x/nameservice/alias.go`文件。拥有这个文件的主要原因是为了防止导入循环。你可以在这里阅读更多关于进口周期的信息: [Golang 进口周期](https://stackoverflow.com/questions/28256923/import-cycle-not-allowed)

首先，导入您创建的“类型”文件夹。

我们将在 alias.go 文件中创建三种类型。

*   常量，这是你定义不可变变量的地方。
*   一个变量，您将定义它来包含诸如您的消息之类的信息。
*   类型，您将在这里定义您在“类型”文件夹中创建的类型。

```
package nameservice

import (
	"github.com/cosmos/sdk-tutorials/nameservice/x/nameservice/keeper"
	"github.com/cosmos/sdk-tutorials/nameservice/x/nameservice/types"
)

const (
	ModuleName   = types.ModuleName
	RouterKey    = types.RouterKey
	StoreKey     = types.StoreKey
	QuerierRoute = types.QuerierRoute
)

var (
	NewKeeper        = keeper.NewKeeper
	NewQuerier       = keeper.NewQuerier
	NewMsgBuyName    = types.NewMsgBuyName
	NewMsgSetName    = types.NewMsgSetName
	NewMsgDeleteName = types.NewMsgDeleteName
	NewWhois         = types.NewWhois
	ModuleCdc        = types.ModuleCdc
	RegisterCodec    = types.RegisterCodec
)

type (
	Keeper          = keeper.Keeper
	MsgSetName      = types.MsgSetName
	MsgBuyName      = types.MsgBuyName
	MsgDeleteName   = types.MsgDeleteName
	QueryResResolve = types.QueryResResolve
	QueryResNames   = types.QueryResNames
	Whois           = types.Whois
)
```

现在，您已经为所需的常量、变量和类型添加了别名。我们可以继续创建模块。

接下来以氨基编码格式注册您的类型。

# 编解码器文件

为了[用氨基](https://github.com/tendermint/go-amino#registering-types)注册你的类型，以便它们可以被编码/解码，有一点代码需要放在`./x/nameservice/types/codec.go`中。您创建的任何接口和实现接口的任何结构都需要在`RegisterCodec`函数中声明。在这个模块中，三个`Msg`实现(`SetName`、`BuyName`和`DeleteName`)需要注册，但是您的`Whois`查询返回类型不需要注册。此外，我们定义了一个模块特定的编解码器供以后使用。

```
package types

import (
	"github.com/cosmos/cosmos-sdk/codec"
)

// ModuleCdc is the codec for the module
var ModuleCdc = codec.New()

func init() {
	RegisterCodec(ModuleCdc)
}

// RegisterCodec registers concrete types on the Amino codec
func RegisterCodec(cdc *codec.Codec) {
	cdc.RegisterConcrete(MsgSetName{}, "nameservice/SetName", nil)
	cdc.RegisterConcrete(MsgBuyName{}, "nameservice/BuyName", nil)
	cdc.RegisterConcrete(MsgDeleteName{}, "nameservice/DeleteName", nil)
}
```

接下来，您需要定义 CLI 与您的模块的交互。

## 名称服务模块 CLI

Cosmos SDK 使用 [`cobra`](https://github.com/spf13/cobra) 库进行 CLI 交互。这个库使得每个模块可以很容易地公开自己的命令。要开始定义用户与模块的 CLI 交互，请创建以下文件:

*   `./x/nameservice/client/cli/query.go`
*   `./x/nameservice/client/cli/tx.go`

## 问题

从`query.go`开始。在这里，为您的每个模块`Queriers` ( `resolve`)和`whois`)定义`cobra.Command`:

```
package cli

import (
	"fmt"

	"github.com/cosmos/cosmos-sdk/client"
	"github.com/cosmos/cosmos-sdk/client/context"
	"github.com/cosmos/cosmos-sdk/client/flags"
	"github.com/cosmos/cosmos-sdk/codec"
	"github.com/cosmos/sdk-tutorials/nameservice/x/nameservice/types"
	"github.com/spf13/cobra"
)

func GetQueryCmd(storeKey string, cdc *codec.Codec) *cobra.Command {
	nameserviceQueryCmd := &cobra.Command{
		Use:                        types.ModuleName,
		Short:                      "Querying commands for the nameservice module",
		DisableFlagParsing:         true,
		SuggestionsMinimumDistance: 2,
		RunE:                       client.ValidateCmd,
	}
	nameserviceQueryCmd.AddCommand(flags.GetCommands(
		GetCmdResolveName(storeKey, cdc),
		GetCmdWhois(storeKey, cdc),
		GetCmdNames(storeKey, cdc),
	)...)

	return nameserviceQueryCmd
}

// GetCmdResolveName queries information about a name
func GetCmdResolveName(queryRoute string, cdc *codec.Codec) *cobra.Command {
	return &cobra.Command{
		Use:   "resolve [name]",
		Short: "resolve name",
		Args:  cobra.ExactArgs(1),
		RunE: func(cmd *cobra.Command, args []string) error {
			cliCtx := context.NewCLIContext().WithCodec(cdc)
			name := args[0]

			res, _, err := cliCtx.QueryWithData(fmt.Sprintf("custom/%s/resolve/%s", queryRoute, name), nil)
			if err != nil {
				fmt.Printf("could not resolve name - %s \n", name)
				return nil
			}

			var out types.QueryResResolve
			cdc.MustUnmarshalJSON(res, &out)
			return cliCtx.PrintOutput(out)
		},
	}
}

// GetCmdWhois queries information about a domain
func GetCmdWhois(queryRoute string, cdc *codec.Codec) *cobra.Command {
	return &cobra.Command{
		Use:   "whois [name]",
		Short: "Query whois info of name",
		Args:  cobra.ExactArgs(1),
		RunE: func(cmd *cobra.Command, args []string) error {
			cliCtx := context.NewCLIContext().WithCodec(cdc)
			name := args[0]

			res, _, err := cliCtx.QueryWithData(fmt.Sprintf("custom/%s/whois/%s", queryRoute, name), nil)
			if err != nil {
				fmt.Printf("could not resolve whois - %s \n", name)
				return nil
			}

			var out types.Whois
			cdc.MustUnmarshalJSON(res, &out)
			return cliCtx.PrintOutput(out)
		},
	}
}

// GetCmdNames queries a list of all names
func GetCmdNames(queryRoute string, cdc *codec.Codec) *cobra.Command {
	return &cobra.Command{
		Use:   "names",
		Short: "names",
		// Args:  cobra.ExactArgs(1),
		RunE: func(cmd *cobra.Command, args []string) error {
			cliCtx := context.NewCLIContext().WithCodec(cdc)

			res, _, err := cliCtx.QueryWithData(fmt.Sprintf("custom/%s/names", queryRoute), nil)
			if err != nil {
				fmt.Printf("could not get query names\n")
				return nil
			}

			var out types.QueryResNames
			cdc.MustUnmarshalJSON(res, &out)
			return cliCtx.PrintOutput(out)
		},
	}
}
```

上述代码的注释:

*   CLI 引入了新的`context` : [`CLIContext`](https://godoc.org/github.com/cosmos/cosmos-sdk/client/context#CLIContext) 。它携带 CLI 交互所需的用户输入和应用程序配置的相关数据。
*   `cliCtx.QueryWithData()`函数所需的`path`直接映射到查询路由器中的名称。
    *   路径的第一部分用于区分 SDK 应用程序可能的查询类型:`custom`代表`Queriers`。
    *   第二部分(`nameservice`)是将查询路由到的模块的名称。
    *   最后，在将要调用的模块中有一个特定的查询程序。
    *   在这个例子中，第四部分是查询。这是可行的，因为查询参数是一个简单的字符串。要启用更复杂的查询输入，您需要使用 [`.QueryWithData()`](https://godoc.org/github.com/cosmos/cosmos-sdk/client/context#CLIContext.QueryWithData) 函数的第二个参数传入`data`。关于这方面的例子，请参见锁定模块中的[查询程序。](https://github.com/cosmos/cosmos-sdk/blob/5af6bd77aa6c0e8facc936947a3365416892e44d/x/staking/keeper/querier.go)

# 处理

既然已经定义了查询交互，那么是时候继续进行`tx.go`中的事务生成了:

> *注意*:您的应用程序需要导入您刚刚编写的代码。在这里，导入路径被设置为这个存储库(`github.com/cosmos/sdk-tutorials/nameservice/x/nameservice`)。如果您在自己的 repo 中跟进，您将需要更改导入路径以反映这一点(`github.com/{ .Username }/{ .Project.Repo }/x/nameservice`)。

```
package cli

import (
	"bufio"

	"github.com/spf13/cobra"

	"github.com/cosmos/cosmos-sdk/client"
	"github.com/cosmos/cosmos-sdk/client/context"
	"github.com/cosmos/cosmos-sdk/client/flags"
	"github.com/cosmos/cosmos-sdk/codec"
	sdk "github.com/cosmos/cosmos-sdk/types"
	"github.com/cosmos/cosmos-sdk/x/auth"
	"github.com/cosmos/cosmos-sdk/x/auth/client/utils"
	"github.com/cosmos/sdk-tutorials/nameservice/x/nameservice/types"
)

func GetTxCmd(storeKey string, cdc *codec.Codec) *cobra.Command {
	nameserviceTxCmd := &cobra.Command{
		Use:                        types.ModuleName,
		Short:                      "Nameservice transaction subcommands",
		DisableFlagParsing:         true,
		SuggestionsMinimumDistance: 2,
		RunE:                       client.ValidateCmd,
	}

	nameserviceTxCmd.AddCommand(flags.PostCommands(
		GetCmdBuyName(cdc),
		GetCmdSetName(cdc),
		GetCmdDeleteName(cdc),
	)...)

	return nameserviceTxCmd
}

// GetCmdBuyName is the CLI command for sending a BuyName transaction
func GetCmdBuyName(cdc *codec.Codec) *cobra.Command {
	return &cobra.Command{
		Use:   "buy-name [name] [amount]",
		Short: "bid for existing name or claim new name",
		Args:  cobra.ExactArgs(2),
		RunE: func(cmd *cobra.Command, args []string) error {
			inBuf := bufio.NewReader(cmd.InOrStdin())
			cliCtx := context.NewCLIContext().WithCodec(cdc)

			txBldr := auth.NewTxBuilderFromCLI(inBuf).WithTxEncoder(utils.GetTxEncoder(cdc))

			coins, err := sdk.ParseCoins(args[1])
			if err != nil {
				return err
			}

			msg := types.NewMsgBuyName(args[0], coins, cliCtx.GetFromAddress())
			err = msg.ValidateBasic()
			if err != nil {
				return err
			}

			return utils.GenerateOrBroadcastMsgs(cliCtx, txBldr, []sdk.Msg{msg})
		},
	}
}

// GetCmdSetName is the CLI command for sending a SetName transaction
func GetCmdSetName(cdc *codec.Codec) *cobra.Command {
	return &cobra.Command{
		Use:   "set-name [name] [value]",
		Short: "set the value associated with a name that you own",
		Args:  cobra.ExactArgs(2),
		RunE: func(cmd *cobra.Command, args []string) error {
			cliCtx := context.NewCLIContext().WithCodec(cdc)
			inBuf := bufio.NewReader(cmd.InOrStdin())
			txBldr := auth.NewTxBuilderFromCLI(inBuf).WithTxEncoder(utils.GetTxEncoder(cdc))

			// if err := cliCtx.EnsureAccountExists(); err != nil {
			// 	return err
			// }

			msg := types.NewMsgSetName(args[0], args[1], cliCtx.GetFromAddress())
			err := msg.ValidateBasic()
			if err != nil {
				return err
			}

			// return utils.CompleteAndBroadcastTxCLI(txBldr, cliCtx, msgs)
			return utils.GenerateOrBroadcastMsgs(cliCtx, txBldr, []sdk.Msg{msg})
		},
	}
}

// GetCmdDeleteName is the CLI command for sending a DeleteName transaction
func GetCmdDeleteName(cdc *codec.Codec) *cobra.Command {
	return &cobra.Command{
		Use:   "delete-name [name]",
		Short: "delete the name that you own along with it's associated fields",
		Args:  cobra.ExactArgs(1),
		RunE: func(cmd *cobra.Command, args []string) error {
			cliCtx := context.NewCLIContext().WithCodec(cdc)
			inBuf := bufio.NewReader(cmd.InOrStdin())
			txBldr := auth.NewTxBuilderFromCLI(inBuf).WithTxEncoder(utils.GetTxEncoder(cdc))

			msg := types.NewMsgDeleteName(args[0], cliCtx.GetFromAddress())
			err := msg.ValidateBasic()
			if err != nil {
				return err
			}

			// return utils.CompleteAndBroadcastTxCLI(txBldr, cliCtx, msgs)
			return utils.GenerateOrBroadcastMsgs(cliCtx, txBldr, []sdk.Msg{msg})
		},
	}
}
```

上述代码的注释:

*   这里用的是`authcmd`包。godocs 有更多关于用法的信息。它提供对由 CLI 控制的帐户的访问，并有助于签名。

现在您已经准备好定义路由，REST 客户机将使用这些路由与您的模块进行通信。

## 名称服务模块 Rest 接口

您的模块还可以公开一个 REST 接口，以允许对模块功能的编程访问。要开始，导航到`./x/nameservice/client/rest/rest.go`该文件将保存 HTTP 处理程序:

添加`imports`和`const`开始:

> *注意*:您的应用程序需要导入您刚刚编写的代码。在这里，导入路径被设置为这个存储库(`github.com/cosmos/sdk-tutorials/nameservice/x/nameservice`)。如果您在自己的 repo 中跟进，您将需要更改导入路径以反映这一点(`github.com/{ .Username }/{ .Project.Repo }/x/nameservice`)。

```
package rest

import (
	"fmt"

	"github.com/cosmos/cosmos-sdk/client/context"

	"github.com/gorilla/mux"
)

const (
	restName = "name"
)
```

## 注册路由

首先，在一个`RegisterRoutes`函数中为您的模块定义 REST 客户端接口。让所有的路由都以您的模块名开始，以防止与其他模块的路由发生名称空间冲突:

```
// RegisterRoutes - Central function to define routes that get registered by the main application
func RegisterRoutes(cliCtx context.CLIContext, r *mux.Router, storeName string) {
	r.HandleFunc(fmt.Sprintf("/%s/names", storeName), namesHandler(cliCtx, storeName)).Methods("GET")
	r.HandleFunc(fmt.Sprintf("/%s/names", storeName), buyNameHandler(cliCtx)).Methods("POST")
	r.HandleFunc(fmt.Sprintf("/%s/names", storeName), setNameHandler(cliCtx)).Methods("PUT")
	r.HandleFunc(fmt.Sprintf("/%s/names/{%s}", storeName, restName), resolveNameHandler(cliCtx, storeName)).Methods("GET")
	r.HandleFunc(fmt.Sprintf("/%s/names/{%s}/whois", storeName, restName), whoIsHandler(cliCtx, storeName)).Methods("GET")
	r.HandleFunc(fmt.Sprintf("/%s/names", storeName), deleteNameHandler(cliCtx)).Methods("DELETE")
}
```

## 查询处理程序

首先创建一个`query.go`文件来存放所有的查询。

接下来，是时候定义上面提到的处理程序了。这些方法与前面定义的 CLI 方法非常相似。从查询`whois`和`resolve`开始:

```
package rest

import (
	"fmt"
	"net/http"

	"github.com/cosmos/cosmos-sdk/client/context"

	"github.com/cosmos/cosmos-sdk/types/rest"

	"github.com/gorilla/mux"
)

func resolveNameHandler(cliCtx context.CLIContext, storeName string) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		vars := mux.Vars(r)
		paramType := vars[restName]

		res, _, err := cliCtx.QueryWithData(fmt.Sprintf("custom/%s/resolve/%s", storeName, paramType), nil)
		if err != nil {
			rest.WriteErrorResponse(w, http.StatusNotFound, err.Error())
			return
		}

		rest.PostProcessResponse(w, cliCtx, res)
	}
}

func whoIsHandler(cliCtx context.CLIContext, storeName string) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		vars := mux.Vars(r)
		paramType := vars[restName]

		res, _, err := cliCtx.QueryWithData(fmt.Sprintf("custom/%s/whois/%s", storeName, paramType), nil)
		if err != nil {
			rest.WriteErrorResponse(w, http.StatusNotFound, err.Error())
			return
		}

		rest.PostProcessResponse(w, cliCtx, res)
	}
}

func namesHandler(cliCtx context.CLIContext, storeName string) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		res, _, err := cliCtx.QueryWithData(fmt.Sprintf("custom/%s/names", storeName), nil)
		if err != nil {
			rest.WriteErrorResponse(w, http.StatusNotFound, err.Error())
			return
		}
		rest.PostProcessResponse(w, cliCtx, res)
	}
}
```

上述代码的注释:

*   注意，我们使用相同的`cliCtx.QueryWithData`函数来获取数据
*   这些功能与相应的 CLI 功能几乎相同

## Tx 处理程序

首先定义一个`tx.go`文件来保存所有的 tx rest 端点。

现在定义`buyName`、`setName`和`deleteName`交易路线。请注意，它们实际上并没有发送购买、设置和删除姓名的事务。这将需要发送一个密码连同请求，这将是一个安全问题。相反，这些端点构建并返回每个特定的事务，然后可以以安全的方式对其进行签名，然后使用类似`/txs`的标准端点向网络广播。

```
package rest

import (
	"net/http"

	"github.com/cosmos/cosmos-sdk/client/context"
	"github.com/cosmos/sdk-tutorials/nameservice/x/nameservice/types"

	sdk "github.com/cosmos/cosmos-sdk/types"
	"github.com/cosmos/cosmos-sdk/types/rest"
	"github.com/cosmos/cosmos-sdk/x/auth/client/utils"
)

type buyNameReq struct {
	BaseReq rest.BaseReq `json:"base_req"`
	Name    string       `json:"name"`
	Amount  string       `json:"amount"`
	Buyer   string       `json:"buyer"`
}

func buyNameHandler(cliCtx context.CLIContext) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var req buyNameReq

		if !rest.ReadRESTReq(w, r, cliCtx.Codec, &req) {
			rest.WriteErrorResponse(w, http.StatusBadRequest, "failed to parse request")
			return
		}

		baseReq := req.BaseReq.Sanitize()
		if !baseReq.ValidateBasic(w) {
			return
		}

		addr, err := sdk.AccAddressFromBech32(req.Buyer)
		if err != nil {
			rest.WriteErrorResponse(w, http.StatusBadRequest, err.Error())
			return
		}

		coins, err := sdk.ParseCoins(req.Amount)
		if err != nil {
			rest.WriteErrorResponse(w, http.StatusBadRequest, err.Error())
			return
		}

		// create the message
		msg := types.NewMsgBuyName(req.Name, coins, addr)
		err = msg.ValidateBasic()
		if err != nil {
			rest.WriteErrorResponse(w, http.StatusBadRequest, err.Error())
			return
		}

		utils.WriteGenerateStdTxResponse(w, cliCtx, baseReq, []sdk.Msg{msg})
	}
}

type setNameReq struct {
	BaseReq rest.BaseReq `json:"base_req"`
	Name    string       `json:"name"`
	Value   string       `json:"value"`
	Owner   string       `json:"owner"`
}

func setNameHandler(cliCtx context.CLIContext) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var req setNameReq
		if !rest.ReadRESTReq(w, r, cliCtx.Codec, &req) {
			rest.WriteErrorResponse(w, http.StatusBadRequest, "failed to parse request")
			return
		}

		baseReq := req.BaseReq.Sanitize()
		if !baseReq.ValidateBasic(w) {
			return
		}

		addr, err := sdk.AccAddressFromBech32(req.Owner)
		if err != nil {
			rest.WriteErrorResponse(w, http.StatusBadRequest, err.Error())
			return
		}

		// create the message
		msg := types.NewMsgSetName(req.Name, req.Value, addr)
		err = msg.ValidateBasic()
		if err != nil {
			rest.WriteErrorResponse(w, http.StatusBadRequest, err.Error())
			return
		}

		utils.WriteGenerateStdTxResponse(w, cliCtx, baseReq, []sdk.Msg{msg})
	}
}

type deleteNameReq struct {
	BaseReq rest.BaseReq `json:"base_req"`
	Name    string       `json:"name"`
	Owner   string       `json:"owner"`
}

func deleteNameHandler(cliCtx context.CLIContext) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var req deleteNameReq
		if !rest.ReadRESTReq(w, r, cliCtx.Codec, &req) {
			rest.WriteErrorResponse(w, http.StatusBadRequest, "failed to parse request")
			return
		}

		baseReq := req.BaseReq.Sanitize()
		if !baseReq.ValidateBasic(w) {
			return
		}

		addr, err := sdk.AccAddressFromBech32(req.Owner)
		if err != nil {
			rest.WriteErrorResponse(w, http.StatusBadRequest, err.Error())
			return
		}

		// create the message
		msg := types.NewMsgDeleteName(req.Name, addr)
		err = msg.ValidateBasic()
		if err := msg.ValidateBasic(); err != nil {
			rest.WriteErrorResponse(w, http.StatusBadRequest, err.Error())
			return
		}

		utils.WriteGenerateStdTxResponse(w, cliCtx, baseReq, []sdk.Msg{msg})
	}
}
```

上述代码的注释:

*   [`BaseReq`](https://godoc.org/github.com/cosmos/cosmos-sdk/client/utils#BaseReq) 包含进行交易的基本必填字段(使用哪个密钥、如何解码、您在哪个链上，等等...)并被设计成如图所示嵌入。
*   `baseReq.ValidateBasic`为您处理设置响应代码，因此您在使用这些函数时无需担心处理错误或成功。

接下来是通过实现 AppModule 接口来扩充`nameservice`的时候了。

# AppModule 接口

Cosmos SDK 为模块提供了一个标准接口。这个 [`AppModule`](https://github.com/cosmos/cosmos-sdk/blob/master/types/module.go) 接口要求模块提供一组由`ModuleBasicsManager`使用的方法来将它们合并到您的应用程序中。首先，我们将搭建接口并实现**它的一些**方法。然后，我们将把我们的名称服务模块与`auth`和`bank`一起整合到我们的应用程序中。

首先打开两个新文件，`module.go`和`genesis.go`。我们将在`module.go`中实现 AppModule 接口，在`genesis.go`中实现 genesis 状态管理的特定功能。AppModule 结构上的特定于 genesis 的方法将是对那些在`genesis.go`中定义的方法的直通调用。

让我们从添加下面的代码到`module.go`开始。脚手架工具已经用需要的数据填充了所有的功能，但是仍然有一些待办事项。您必须在`AppModule`类型中添加该模块所依赖的模块。

```
package nameservice

import (
	"encoding/json"

	"github.com/gorilla/mux"
	"github.com/spf13/cobra"

	"github.com/cosmos/cosmos-sdk/codec"
	"github.com/cosmos/cosmos-sdk/types/module"
	"github.com/cosmos/cosmos-sdk/x/bank"
	"github.com/cosmos/sdk-tutorials/nameservice/x/nameservice/client/cli"
	"github.com/cosmos/sdk-tutorials/nameservice/x/nameservice/client/rest"

	"github.com/cosmos/cosmos-sdk/client/context"
	sdk "github.com/cosmos/cosmos-sdk/types"
	abci "github.com/tendermint/tendermint/abci/types"
)

// type check to ensure the interface is properly implemented
var (
	_ module.AppModule      = AppModule{}
	_ module.AppModuleBasic = AppModuleBasic{}
)

// app module Basics object
type AppModuleBasic struct{}

func (AppModuleBasic) Name() string {
	return ModuleName
}

func (AppModuleBasic) RegisterCodec(cdc *codec.Codec) {
	RegisterCodec(cdc)
}

func (AppModuleBasic) DefaultGenesis() json.RawMessage {
	return ModuleCdc.MustMarshalJSON(DefaultGenesisState())
}

// Validation check of the Genesis
func (AppModuleBasic) ValidateGenesis(bz json.RawMessage) error {
	var data GenesisState
	err := ModuleCdc.UnmarshalJSON(bz, &data)
	if err != nil {
		return err
	}
	// Once json successfully marshalled, passes along to genesis.go
	return ValidateGenesis(data)
}

// Register rest routes
func (AppModuleBasic) RegisterRESTRoutes(ctx context.CLIContext, rtr *mux.Router) {
	rest.RegisterRoutes(ctx, rtr, StoreKey)
}

// Get the root query command of this module
func (AppModuleBasic) GetQueryCmd(cdc *codec.Codec) *cobra.Command {
	return cli.GetQueryCmd(StoreKey, cdc)
}

// Get the root tx command of this module
func (AppModuleBasic) GetTxCmd(cdc *codec.Codec) *cobra.Command {
	return cli.GetTxCmd(StoreKey, cdc)
}

type AppModule struct {
	AppModuleBasic
	keeper     Keeper
	bankKeeper bank.Keeper
}

// NewAppModule creates a new AppModule Object
func NewAppModule(k Keeper, bankKeeper bank.Keeper) AppModule {
	return AppModule{
		AppModuleBasic: AppModuleBasic{},
		keeper:         k,
		bankKeeper:     bankKeeper,
	}
}

func (AppModule) Name() string {
	return ModuleName
}

func (am AppModule) RegisterInvariants(ir sdk.InvariantRegistry) {}

func (am AppModule) Route() string {
	return RouterKey
}

func (am AppModule) NewHandler() sdk.Handler {
	return NewHandler(am.keeper)
}
func (am AppModule) QuerierRoute() string {
	return QuerierRoute
}

func (am AppModule) NewQuerierHandler() sdk.Querier {
	return NewQuerier(am.keeper)
}

func (am AppModule) BeginBlock(_ sdk.Context, _ abci.RequestBeginBlock) {}

func (am AppModule) EndBlock(sdk.Context, abci.RequestEndBlock) []abci.ValidatorUpdate {
	return []abci.ValidatorUpdate{}
}

func (am AppModule) InitGenesis(ctx sdk.Context, data json.RawMessage) []abci.ValidatorUpdate {
	var genesisState GenesisState
	ModuleCdc.MustUnmarshalJSON(data, &genesisState)
	InitGenesis(ctx, am.keeper, genesisState)
	return []abci.ValidatorUpdate{}
}

func (am AppModule) ExportGenesis(ctx sdk.Context) json.RawMessage {
	gs := ExportGenesis(ctx, am.keeper)
	return ModuleCdc.MustMarshalJSON(gs)
}
```

要查看 AppModule 实现的更多示例，请查看 SDK 中的其他一些模块，如 [x/staking](https://github.com/cosmos/cosmos-sdk/blob/master/x/staking/genesis.go)

接下来，我们需要实现上面提到的特定于 genesis 的方法。

## 起源

AppModule 接口包括许多用于初始化和导出链的 GenesisState 的函数。`ModuleBasicManager`在启动、停止或导出链时调用每个模块上的这些函数。这是一个非常基本的实现，您可以对其进行扩展。

转到`x/nameservice/genesis.go`你会发现少了几样东西。我们必须根据模块的需要来填充它们。下面你会看到缺少了什么:

```
package nameservice

import (
	"fmt"

	sdk "github.com/cosmos/cosmos-sdk/types"
)

type GenesisState struct {
	WhoisRecords []Whois `json:"whois_records"`
}

func NewGenesisState(whoIsRecords []Whois) GenesisState {
	return GenesisState{WhoisRecords: nil}
}

func ValidateGenesis(data GenesisState) error {
	for _, record := range data.WhoisRecords {
		if record.Owner == nil {
			return fmt.Errorf("invalid WhoisRecord: Value: %s. Error: Missing Owner", record.Value)
		}
		if record.Value == "" {
			return fmt.Errorf("invalid WhoisRecord: Owner: %s. Error: Missing Value", record.Owner)
		}
		if record.Price == nil {
			return fmt.Errorf("invalid WhoisRecord: Value: %s. Error: Missing Price", record.Value)
		}
	}
	return nil
}

func DefaultGenesisState() GenesisState {
	return GenesisState{
		WhoisRecords: []Whois{},
	}
}

func InitGenesis(ctx sdk.Context, keeper Keeper, data GenesisState) {
	for _, record := range data.WhoisRecords {
		keeper.SetWhois(ctx, record.Value, record)
	}
}

func ExportGenesis(ctx sdk.Context, k Keeper) GenesisState {
	var records []Whois
	iterator := k.GetNamesIterator(ctx)
	for ; iterator.Valid(); iterator.Next() {

		name := string(iterator.Key())
		whois := k.GetWhois(ctx, name)
		records = append(records, whois)

	}
	return GenesisState{WhoisRecords: records}
}
```

接下来，我们将定义什么是起源状态，默认的起源和验证它的方法，这样当我们用预先存在的状态开始链时，我们就不会遇到任何错误。

```
package types

import (
	"fmt"
)

type GenesisState struct {
	WhoisRecords []Whois `json:"whois_records"`
}

func NewGenesisState(whoIsRecords []Whois) GenesisState {
	return GenesisState{WhoisRecords: nil}
}

func ValidateGenesis(data GenesisState) error {
	for _, record := range data.WhoisRecords {
		if record.Owner == nil {
			return fmt.Errorf("invalid WhoisRecord: Value: %s. Error: Missing Owner", record.Value)
		}
		if record.Value == "" {
			return fmt.Errorf("invalid WhoisRecord: Owner: %s. Error: Missing Value", record.Owner)
		}
		if record.Price == nil {
			return fmt.Errorf("invalid WhoisRecord: Value: %s. Error: Missing Price", record.Value)
		}
	}
	return nil
}

func DefaultGenesisState() GenesisState {
	return GenesisState{
		WhoisRecords: []Whois{},
	}
}
```

关于上述代码的几点注意事项:

*   验证所提供的起源状态，以确保预期的不变量保持不变
*   `DefaultGenesisState()`多用于测试。这提供了一个最小的 GenesisState。
*   `InitGenesis()`在链启动时被调用，该函数将起源状态导入到保持器中。
*   `ExportGenesis()`在停止链后被调用，该函数将应用程序状态加载到 GenesisState 结构中，以便稍后与来自其他模块的数据一起导出到`genesis.json`。

现在，您的模块已经具备了整合到您的 Cosmos SDK 应用程序中所需的一切。

# 完整应用程序

现在你的模块已经准备好了，它可以被合并到`./app.go`文件中。让我们从将新的名称服务模块添加到导入开始:

> *注意*:您的应用程序需要导入您刚刚编写的代码。在这里，导入路径被设置为这个存储库(`github.com/cosmos/sdk-tutorials/nameservice/x/nameservice`)。如果您在自己的 repo 中跟进，您将需要更改导入路径以反映这一点(`github.com/{ .Username }/{ .Project.Repo }/x/nameservice`)。

```
package app

import (
	"encoding/json"
	"os"

	abci "github.com/tendermint/tendermint/abci/types"
	"github.com/tendermint/tendermint/libs/log"
	tmos "github.com/tendermint/tendermint/libs/os"
	tmtypes "github.com/tendermint/tendermint/types"
	dbm "github.com/tendermint/tm-db"

	bam "github.com/cosmos/cosmos-sdk/baseapp"
	"github.com/cosmos/cosmos-sdk/codec"
	"github.com/cosmos/cosmos-sdk/simapp"
	sdk "github.com/cosmos/cosmos-sdk/types"
	"github.com/cosmos/cosmos-sdk/types/module"
	"github.com/cosmos/cosmos-sdk/version"
	"github.com/cosmos/cosmos-sdk/x/auth"
	"github.com/cosmos/cosmos-sdk/x/auth/vesting"
	"github.com/cosmos/cosmos-sdk/x/bank"
	distr "github.com/cosmos/cosmos-sdk/x/distribution"
	"github.com/cosmos/cosmos-sdk/x/genutil"
	"github.com/cosmos/cosmos-sdk/x/params"
	"github.com/cosmos/cosmos-sdk/x/slashing"
	"github.com/cosmos/cosmos-sdk/x/staking"
	"github.com/cosmos/cosmos-sdk/x/supply"

	"github.com/cosmos/sdk-tutorials/nameservice/x/nameservice"
)

const appName = "nameservice"

var (
	// default home directories for the application CLI
	DefaultCLIHome = os.ExpandEnv("$HOME/.nscli")

	// DefaultNodeHome sets the folder where the applcation data and configuration will be stored
	DefaultNodeHome = os.ExpandEnv("$HOME/.nsd")

	// NewBasicManager is in charge of setting up basic module elements
	ModuleBasics = module.NewBasicManager(
		genutil.AppModuleBasic{},
		auth.AppModuleBasic{},
		bank.AppModuleBasic{},
		staking.AppModuleBasic{},
		distr.AppModuleBasic{},
		params.AppModuleBasic{},
		slashing.AppModuleBasic{},
		supply.AppModuleBasic{},

		nameservice.AppModule{},
	)
	// account permissions
	maccPerms = map[string][]string{
		auth.FeeCollectorName:     nil,
		distr.ModuleName:          nil,
		staking.BondedPoolName:    {supply.Burner, supply.Staking},
		staking.NotBondedPoolName: {supply.Burner, supply.Staking},
	}
)
```

接下来，您需要将商店的键和`Keepers`添加到您的`nameServiceApp`结构中。

```
type nameServiceApp struct {
	*bam.BaseApp
	cdc *codec.Codec

	// keys to access the substores
	keys  map[string]*sdk.KVStoreKey
	tkeys map[string]*sdk.TransientStoreKey

	// subspaces
	subspaces map[string]params.Subspace

	// Keepers
	accountKeeper  auth.AccountKeeper
	bankKeeper     bank.Keeper
	stakingKeeper  staking.Keeper
	slashingKeeper slashing.Keeper
	distrKeeper    distr.Keeper
	supplyKeeper   supply.Keeper
	paramsKeeper   params.Keeper
	nsKeeper       nameservice.Keeper

	// Module Manager
	mm *module.Manager

	// simulation manager
	sm *module.SimulationManager
}

// verify app interface at compile time
var _ simapp.App = (*nameServiceApp)(nil)

// NewNameServiceApp is a constructor function for nameServiceApp
func NewNameServiceApp(
	logger log.Logger, db dbm.DB, baseAppOptions ...func(*bam.BaseApp),
) *nameServiceApp {

	// First define the top level codec that will be shared by the different modules
	cdc := MakeCodec()

	// BaseApp handles interactions with Tendermint through the ABCI protocol
	bApp := bam.NewBaseApp(appName, logger, db, auth.DefaultTxDecoder(cdc), baseAppOptions...)

	bApp.SetAppVersion(version.Version)

	keys := sdk.NewKVStoreKeys(bam.MainStoreKey, auth.StoreKey, staking.StoreKey,
		supply.StoreKey, distr.StoreKey, slashing.StoreKey, params.StoreKey, nameservice.StoreKey)

	tkeys := sdk.NewTransientStoreKeys(params.TStoreKey)

	// Here you initialize your application with the store keys it requires
	var app = &nameServiceApp{
		BaseApp:   bApp,
		cdc:       cdc,
		keys:      keys,
		tkeys:     tkeys,
		subspaces: make(map[string]params.Subspace),
	}
}
```

此时，构造函数仍然缺少重要的逻辑。也就是说，它需要:

*   从每个期望的模块实例化所需的`Keepers`。
*   生成每个`Keeper`需要的`storeKeys`。
*   从每个模块注册`Handler` s。为此使用了`baseapp`的`router`中的`AddRoute()`方法。
*   从每个模块注册`Querier` s。为此使用了`baseapp`的`queryRouter`中的`AddRoute()`方法。
*   将`KVStore`安装到`baseApp`多商店中提供的钥匙上。
*   设置`initChainer`用于定义初始应用状态。

最终的构造函数应该如下所示:

```
// NewNameServiceApp is a constructor function for nameServiceApp
func NewNameServiceApp(
	logger log.Logger, db dbm.DB, baseAppOptions ...func(*bam.BaseApp),
) *nameServiceApp {

	// First define the top level codec that will be shared by the different modules
	cdc := MakeCodec()

	// BaseApp handles interactions with Tendermint through the ABCI protocol
	bApp := bam.NewBaseApp(appName, logger, db, auth.DefaultTxDecoder(cdc), baseAppOptions...)

	bApp.SetAppVersion(version.Version)

	keys := sdk.NewKVStoreKeys(bam.MainStoreKey, auth.StoreKey, staking.StoreKey,
		supply.StoreKey, distr.StoreKey, slashing.StoreKey, params.StoreKey, nameservice.StoreKey)

	tkeys := sdk.NewTransientStoreKeys(params.TStoreKey)

	// Here you initialize your application with the store keys it requires
	var app = &nameServiceApp{
		BaseApp:   bApp,
		cdc:       cdc,
		keys:      keys,
		tkeys:     tkeys,
		subspaces: make(map[string]params.Subspace),
	}

	// The ParamsKeeper handles parameter storage for the application
	app.paramsKeeper = params.NewKeeper(app.cdc, keys[params.StoreKey], tkeys[params.TStoreKey])
	// Set specific supspaces
	app.subspaces[auth.ModuleName] = app.paramsKeeper.Subspace(auth.DefaultParamspace)
	app.subspaces[bank.ModuleName] = app.paramsKeeper.Subspace(bank.DefaultParamspace)
	app.subspaces[staking.ModuleName] = app.paramsKeeper.Subspace(staking.DefaultParamspace)
	app.subspaces[distr.ModuleName] = app.paramsKeeper.Subspace(distr.DefaultParamspace)
	app.subspaces[slashing.ModuleName] = app.paramsKeeper.Subspace(slashing.DefaultParamspace)

	// The AccountKeeper handles address -> account lookups
	app.accountKeeper = auth.NewAccountKeeper(
		app.cdc,
		keys[auth.StoreKey],
		app.subspaces[auth.ModuleName],
		auth.ProtoBaseAccount,
	)

	// The BankKeeper allows you perform sdk.Coins interactions
	app.bankKeeper = bank.NewBaseKeeper(
		app.accountKeeper,
		app.subspaces[bank.ModuleName],
		app.ModuleAccountAddrs(),
	)

	// The SupplyKeeper collects transaction fees and renders them to the fee distribution module
	app.supplyKeeper = supply.NewKeeper(
		app.cdc,
		keys[supply.StoreKey],
		app.accountKeeper,
		app.bankKeeper,
		maccPerms,
	)

	// The staking keeper
	stakingKeeper := staking.NewKeeper(
		app.cdc,
		keys[staking.StoreKey],
		app.supplyKeeper,
		app.subspaces[staking.ModuleName],
	)

	app.distrKeeper = distr.NewKeeper(
		app.cdc,
		keys[distr.StoreKey],
		app.subspaces[distr.ModuleName],
		&stakingKeeper,
		app.supplyKeeper,
		auth.FeeCollectorName,
		app.ModuleAccountAddrs(),
	)

	app.slashingKeeper = slashing.NewKeeper(
		app.cdc,
		keys[slashing.StoreKey],
		&stakingKeeper,
		app.subspaces[slashing.ModuleName],
	)

	// register the staking hooks
	// NOTE: stakingKeeper above is passed by reference, so that it will contain these hooks
	app.stakingKeeper = *stakingKeeper.SetHooks(
		staking.NewMultiStakingHooks(
			app.distrKeeper.Hooks(),
			app.slashingKeeper.Hooks()),
	)

	// The NameserviceKeeper is the Keeper from the module for this tutorial
	// It handles interactions with the namestore
	app.nsKeeper = nameservice.NewKeeper(
		app.cdc,
		keys[nameservice.StoreKey],
		app.bankKeeper,
	)

	app.mm = module.NewManager(
		genutil.NewAppModule(app.accountKeeper, app.stakingKeeper, app.BaseApp.DeliverTx),
		auth.NewAppModule(app.accountKeeper),
		bank.NewAppModule(app.bankKeeper, app.accountKeeper),
		nameservice.NewAppModule(app.nsKeeper, app.bankKeeper),
		supply.NewAppModule(app.supplyKeeper, app.accountKeeper),
		distr.NewAppModule(app.distrKeeper, app.accountKeeper, app.supplyKeeper, app.stakingKeeper),
		slashing.NewAppModule(app.slashingKeeper, app.accountKeeper, app.stakingKeeper),
		staking.NewAppModule(app.stakingKeeper, app.accountKeeper, app.supplyKeeper),
	)

	app.mm.SetOrderBeginBlockers(distr.ModuleName, slashing.ModuleName)
	app.mm.SetOrderEndBlockers(staking.ModuleName)

	// Sets the order of Genesis - Order matters, genutil is to always come last
	// NOTE: The genutils moodule must occur after staking so that pools are
	// properly initialized with tokens from genesis accounts.
	app.mm.SetOrderInitGenesis(
		distr.ModuleName,
		staking.ModuleName,
		auth.ModuleName,
		bank.ModuleName,
		slashing.ModuleName,
		nameservice.ModuleName,
		supply.ModuleName,
		genutil.ModuleName,
	)

	// register all module routes and module queriers
	app.mm.RegisterRoutes(app.Router(), app.QueryRouter())

	// The initChainer handles translating the genesis.json file into initial state for the network
	app.SetInitChainer(app.InitChainer)
	app.SetBeginBlocker(app.BeginBlocker)
	app.SetEndBlocker(app.EndBlocker)

	// The AnteHandler handles signature verification and transaction pre-processing
	app.SetAnteHandler(
		auth.NewAnteHandler(
			app.accountKeeper,
			app.supplyKeeper,
			auth.DefaultSigVerificationGasConsumer,
		),
	)

	// initialize stores
	app.MountKVStores(keys)
	app.MountTransientStores(tkeys)

	err := app.LoadLatestVersion(app.keys[bam.MainStoreKey])
	if err != nil {
		tmos.Exit(err.Error())
	}

	return app
}
```

> *注意*:上面提到的 TransientStore 是 KVStore 对于非持久化状态的内存实现。
> 
> 注意模块是如何启动的:顺序很重要！这里的顺序是 Auth-> Bank-> fee collection-> Staking-> Distribution-> Slashing，然后为 Staking 模块设置钩子。这是因为这些模块中的一些依赖于其他模块的存在才能被使用。

`initChainer`定义了在初始链开始时`genesis.json`中的账户如何映射到应用状态。`ExportAppStateAndValidators`函数帮助引导应用程序的初始状态。现在你不需要太担心这些。我们还需要在我们的应用程序`BeginBlocker`、`EndBlocker`和`LoadHeight`中添加一些方法。

构造函数注册了`initChainer`函数，但是它还没有被定义。继续创建它:

```
// GenesisState represents chain state at the start of the chain. Any initial state (account balances) are stored here.
type GenesisState map[string]json.RawMessage

func NewDefaultGenesisState() GenesisState {
	return ModuleBasics.DefaultGenesis()
}

func (app *nameServiceApp) InitChainer(ctx sdk.Context, req abci.RequestInitChain) abci.ResponseInitChain {
	var genesisState GenesisState

	err := app.cdc.UnmarshalJSON(req.AppStateBytes, &genesisState)
	if err != nil {
		panic(err)
	}

	return app.mm.InitGenesis(ctx, genesisState)
}

func (app *nameServiceApp) BeginBlocker(ctx sdk.Context, req abci.RequestBeginBlock) abci.ResponseBeginBlock {
	return app.mm.BeginBlock(ctx, req)
}

func (app *nameServiceApp) EndBlocker(ctx sdk.Context, req abci.RequestEndBlock) abci.ResponseEndBlock {
	return app.mm.EndBlock(ctx, req)
}

// GetKey returns the KVStoreKey for the provided store key
func (app *nameServiceApp) GetKey(storeKey string) *sdk.KVStoreKey {
	return app.keys[storeKey]
}

// GetTKey returns the TransientStoreKey for the provided store key
func (app *nameServiceApp) GetTKey(storeKey string) *sdk.TransientStoreKey {
	return app.tkeys[storeKey]
}

func (app *nameServiceApp) LoadHeight(height int64) error {
	return app.LoadVersion(height, app.keys[bam.MainStoreKey])
}

// Codec returns simapp's codec
func (app *nameServiceApp) Codec() *codec.Codec {
	return app.cdc
}

// SimulationManager implements the SimulationApp interface
func (app *nameServiceApp) SimulationManager() *module.SimulationManager {
	return app.sm
}

// ModuleAccountAddrs returns all the app's module account addresses.
func (app *nameServiceApp) ModuleAccountAddrs() map[string]bool {
	modAccAddrs := make(map[string]bool)
	for acc := range maccPerms {
		modAccAddrs[supply.NewModuleAddress(acc).String()] = true
	}

	return modAccAddrs
}

//_________________________________________________________

func (app *nameServiceApp) ExportAppStateAndValidators(forZeroHeight bool, jailWhiteList []string,
) (appState json.RawMessage, validators []tmtypes.GenesisValidator, err error) {

	// as if they could withdraw from the start of the next block
	ctx := app.NewContext(true, abci.Header{Height: app.LastBlockHeight()})

	genState := app.mm.ExportGenesis(ctx)
	appState, err = codec.MarshalJSONIndent(app.cdc, genState)
	if err != nil {
		return nil, nil, err
	}

	validators = staking.WriteValidators(ctx, app.stakingKeeper)

	return appState, validators, nil
}
```

最后，添加一个助手函数来生成一个氨基 [`*codec.Codec`](https://godoc.org/github.com/cosmos/cosmos-sdk/codec#Codec) ，它正确地注册了应用程序中使用的所有模块:

```
// MakeCodec generates the necessary codecs for Amino
func MakeCodec() *codec.Codec {
	var cdc = codec.New()

	ModuleBasics.RegisterCodec(cdc)
	vesting.RegisterCodec(cdc)
	sdk.RegisterCodec(cdc)
	codec.RegisterCrypto(cdc)

	return cdc
}
```

现在您已经创建了一个包含您的模块的应用程序，是时候构建您的入口点了。

# 入口点

在 Golang 中，惯例是将编译成二进制文件的文件放在项目的`./cmd`文件夹中。对于您的应用程序，您需要创建 2 个二进制文件:

*   `nsd`:这个二进制类似于`bitcoind`或其他加密货币守护进程，它维护 p2p 连接，传播交易，处理本地存储，并提供 RPC 接口与网络交互。在这种情况下，Tendermint 用于联网和交易订购。
*   这个二进制文件提供了允许用户与你的应用程序交互的命令。

首先，在项目目录中创建两个文件，这两个文件将实例化这些二进制文件:

*   `./cmd/nsd/main.go`
*   `./cmd/nscli/main.go`

**T2`nsd`**

首先将以下代码添加到`cmd/nsd/main.go`:

> *注意*:您的应用程序需要导入您刚刚编写的代码。在这里，导入路径被设置为这个存储库(`github.com/cosmos/sdk-tutorials/nameservice`)。如果您在自己的 repo 中跟进，您将需要更改导入路径以反映这一点(`github.com/{ .Username }/{ .Project.Repo }`)。

```
package main

import (
	"encoding/json"
	"io"

	"github.com/cosmos/cosmos-sdk/server"
	"github.com/cosmos/cosmos-sdk/x/staking"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	"github.com/tendermint/tendermint/libs/cli"
	"github.com/tendermint/tendermint/libs/log"

	"github.com/cosmos/cosmos-sdk/baseapp"
	"github.com/cosmos/cosmos-sdk/client/debug"
	"github.com/cosmos/cosmos-sdk/client/flags"
	sdk "github.com/cosmos/cosmos-sdk/types"
	"github.com/cosmos/cosmos-sdk/x/auth"
	genutilcli "github.com/cosmos/cosmos-sdk/x/genutil/client/cli"
	app "github.com/cosmos/sdk-tutorials/nameservice"
	abci "github.com/tendermint/tendermint/abci/types"
	tmtypes "github.com/tendermint/tendermint/types"
	dbm "github.com/tendermint/tm-db"
)

func main() {
	cobra.EnableCommandSorting = false

	cdc := app.MakeCodec()

	config := sdk.GetConfig()
	config.SetBech32PrefixForAccount(sdk.Bech32PrefixAccAddr, sdk.Bech32PrefixAccPub)
	config.SetBech32PrefixForValidator(sdk.Bech32PrefixValAddr, sdk.Bech32PrefixValPub)
	config.SetBech32PrefixForConsensusNode(sdk.Bech32PrefixConsAddr, sdk.Bech32PrefixConsPub)
	config.Seal()

	ctx := server.NewDefaultContext()

	rootCmd := &cobra.Command{
		Use:               "nsd",
		Short:             "nameservice App Daemon (server)",
		PersistentPreRunE: server.PersistentPreRunEFn(ctx),
	}
	// CLI commands to initialize the chain
	rootCmd.AddCommand(genutilcli.InitCmd(ctx, cdc, app.ModuleBasics, app.DefaultNodeHome))
	rootCmd.AddCommand(genutilcli.CollectGenTxsCmd(ctx, cdc, auth.GenesisAccountIterator{}, app.DefaultNodeHome))
	rootCmd.AddCommand(genutilcli.MigrateGenesisCmd(ctx, cdc))
	rootCmd.AddCommand(
		genutilcli.GenTxCmd(
			ctx, cdc, app.ModuleBasics, staking.AppModuleBasic{},
			auth.GenesisAccountIterator{}, app.DefaultNodeHome, app.DefaultCLIHome,
		),
	)
	rootCmd.AddCommand(genutilcli.ValidateGenesisCmd(ctx, cdc, app.ModuleBasics))
	// AddGenesisAccountCmd allows users to add accounts to the genesis file
	rootCmd.AddCommand(AddGenesisAccountCmd(ctx, cdc, app.DefaultNodeHome, app.DefaultCLIHome))
	rootCmd.AddCommand(flags.NewCompletionCmd(rootCmd, true))
	rootCmd.AddCommand(debug.Cmd(cdc))

	server.AddCommands(ctx, cdc, rootCmd, newApp, exportAppStateAndTMValidators)

	// prepare and add flags
	executor := cli.PrepareBaseCmd(rootCmd, "NS", app.DefaultNodeHome)
	err := executor.Execute()
	if err != nil {
		panic(err)
	}
}

func newApp(logger log.Logger, db dbm.DB, traceStore io.Writer) abci.Application {
	return app.NewNameServiceApp(logger, db, baseapp.SetMinGasPrices(viper.GetString(server.FlagMinGasPrices)))
}

func exportAppStateAndTMValidators(
	logger log.Logger, db dbm.DB, traceStore io.Writer, height int64, forZeroHeight bool, jailWhiteList []string,
) (json.RawMessage, []tmtypes.GenesisValidator, error) {

	if height != -1 {
		nsApp := app.NewNameServiceApp(logger, db)
		err := nsApp.LoadHeight(height)
		if err != nil {
			return nil, nil, err
		}
		return nsApp.ExportAppStateAndValidators(forZeroHeight, jailWhiteList)
	}

	nsApp := app.NewNameServiceApp(logger, db)

	return nsApp.ExportAppStateAndValidators(forZeroHeight, jailWhiteList)
}
```

上述代码的注释:

*   上面的大部分代码结合了来自 Tendermint、Cosmos-SDK 和您的名称服务模块的 CLI 命令。

**T2`nscli`**

最后，构建`nscli`命令:

> *注意*:您的应用程序需要导入您刚刚编写的代码。在这里，导入路径被设置为这个存储库(`github.com/cosmos/sdk-tutorials/nameservice`)。如果您在自己的 repo 中跟进，您将需要更改导入路径以反映这一点(`github.com/{ .Username }/{ .Project.Repo }`)。

```
package main

import (
	"os"
	"path"

	"github.com/cosmos/cosmos-sdk/client"
	"github.com/cosmos/cosmos-sdk/client/flags"
	"github.com/cosmos/cosmos-sdk/client/keys"
	"github.com/cosmos/cosmos-sdk/client/lcd"
	"github.com/cosmos/cosmos-sdk/client/rpc"
	sdk "github.com/cosmos/cosmos-sdk/types"
	"github.com/cosmos/cosmos-sdk/version"
	"github.com/cosmos/cosmos-sdk/x/auth"
	authcmd "github.com/cosmos/cosmos-sdk/x/auth/client/cli"
	authrest "github.com/cosmos/cosmos-sdk/x/auth/client/rest"
	"github.com/cosmos/cosmos-sdk/x/bank"
	bankcmd "github.com/cosmos/cosmos-sdk/x/bank/client/cli"
	app "github.com/cosmos/sdk-tutorials/nameservice"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	amino "github.com/tendermint/go-amino"
	"github.com/tendermint/tendermint/libs/cli"
)

func main() {
	cobra.EnableCommandSorting = false

	cdc := app.MakeCodec()

	// Read in the configuration file for the sdk
	config := sdk.GetConfig()
	config.SetBech32PrefixForAccount(sdk.Bech32PrefixAccAddr, sdk.Bech32PrefixAccPub)
	config.SetBech32PrefixForValidator(sdk.Bech32PrefixValAddr, sdk.Bech32PrefixValPub)
	config.SetBech32PrefixForConsensusNode(sdk.Bech32PrefixConsAddr, sdk.Bech32PrefixConsPub)
	config.Seal()

	rootCmd := &cobra.Command{
		Use:   "nscli",
		Short: "nameservice Client",
	}

	// Add --chain-id to persistent flags and mark it required
	rootCmd.PersistentFlags().String(flags.FlagChainID, "", "Chain ID of tendermint node")
	rootCmd.PersistentPreRunE = func(_ *cobra.Command, _ []string) error {
		return initConfig(rootCmd)
	}

	// Construct Root Command
	rootCmd.AddCommand(
		rpc.StatusCommand(),
		client.ConfigCmd(app.DefaultCLIHome),
		queryCmd(cdc),
		txCmd(cdc),
		flags.LineBreak,
		lcd.ServeCommand(cdc, registerRoutes),
		flags.LineBreak,
		keys.Commands(),
		flags.LineBreak,
		version.Cmd,
		flags.NewCompletionCmd(rootCmd, true),
	)

	executor := cli.PrepareMainCmd(rootCmd, "NS", app.DefaultCLIHome)
	err := executor.Execute()

	if err != nil {
		panic(err)
	}
}

func registerRoutes(rs *lcd.RestServer) {
	client.RegisterRoutes(rs.CliCtx, rs.Mux)
	authrest.RegisterTxRoutes(rs.CliCtx, rs.Mux)
	app.ModuleBasics.RegisterRESTRoutes(rs.CliCtx, rs.Mux)
}

func queryCmd(cdc *amino.Codec) *cobra.Command {
	queryCmd := &cobra.Command{
		Use:     "query",
		Aliases: []string{"q"},
		Short:   "Querying subcommands",
	}

	queryCmd.AddCommand(
		authcmd.GetAccountCmd(cdc),
		flags.LineBreak,
		rpc.ValidatorCommand(cdc),
		rpc.BlockCommand(),
		authcmd.QueryTxsByEventsCmd(cdc),
		authcmd.QueryTxCmd(cdc),
		flags.LineBreak,
	)

	// add modules' query commands
	app.ModuleBasics.AddQueryCommands(queryCmd, cdc)

	return queryCmd
}

func txCmd(cdc *amino.Codec) *cobra.Command {
	txCmd := &cobra.Command{
		Use:   "tx",
		Short: "Transactions subcommands",
	}

	txCmd.AddCommand(
		bankcmd.SendTxCmd(cdc),
		flags.LineBreak,
		authcmd.GetSignCommand(cdc),
		authcmd.GetMultiSignCommand(cdc),
		flags.LineBreak,
		authcmd.GetBroadcastCommand(cdc),
		authcmd.GetEncodeCommand(cdc),
		authcmd.GetDecodeCommand(cdc),
		flags.LineBreak,
	)

	// add modules' tx commands
	app.ModuleBasics.AddTxCommands(txCmd, cdc)

	// remove auth and bank commands as they're mounted under the root tx command
	var cmdsToRemove []*cobra.Command

	for _, cmd := range txCmd.Commands() {
		if cmd.Use == auth.ModuleName || cmd.Use == bank.ModuleName {
			cmdsToRemove = append(cmdsToRemove, cmd)
		}
	}

	txCmd.RemoveCommand(cmdsToRemove...)

	return txCmd
}

func initConfig(cmd *cobra.Command) error {
	home, err := cmd.PersistentFlags().GetString(cli.HomeFlag)
	if err != nil {
		return err
	}

	cfgFile := path.Join(home, "config", "config.toml")
	if _, err := os.Stat(cfgFile); err == nil {
		viper.SetConfigFile(cfgFile)

		if err := viper.ReadInConfig(); err != nil {
			return err
		}
	}
	if err := viper.BindPFlag(flags.FlagChainID, cmd.PersistentFlags().Lookup(flags.FlagChainID)); err != nil {
		return err
	}
	if err := viper.BindPFlag(cli.EncodingFlag, cmd.PersistentFlags().Lookup(cli.EncodingFlag)); err != nil {
		return err
	}
	return viper.BindPFlag(cli.OutputFlag, cmd.PersistentFlags().Lookup(cli.OutputFlag))
}
```

注意:

*   该代码结合了来自 Tendermint、Cosmos-SDK 和您的名称服务模块的 CLI 命令。
*   CLI 文档将有助于理解上述代码。
*   您可以在这里看到前面定义的`ModuleClient`。
*   注意路线是如何包含在`registerRoutes`功能中的。

既然已经有了二进制文件，那么是时候处理依赖性管理和构建应用程序了。

## go.mod 和 Makefile

**T2`Makefile`**

通过在根目录中编写一个包含常用命令的`./Makefile`来帮助用户构建您的应用程序。scaffolding 工具创建了一个通用 makefile，您将能够使用它:

> *注意*:下面的 Makefile 包含一些与 Cosmos SDK 和 Tendermint Makefiles 相同的命令。

```
PACKAGES=$(shell go list ./... | grep -v '/simulation')

VERSION := $(shell echo $(shell git describe --tags) | sed 's/^v//')
COMMIT := $(shell git log -1 --format='%H')

ldflags = -X github.com/cosmos/cosmos-sdk/version.Name=NameService \
	-X github.com/cosmos/cosmos-sdk/version.ServerName=nsd \
	-X github.com/cosmos/cosmos-sdk/version.ClientName=nscli \
	-X github.com/cosmos/cosmos-sdk/version.Version=$(VERSION) \
	-X github.com/cosmos/cosmos-sdk/version.Commit=$(COMMIT) 

BUILD_FLAGS := -ldflags '$(ldflags)'

include Makefile.ledger
all: install

install: go.sum
		@echo "--> Installing nsd & nscli"
		@go install -mod=readonly $(BUILD_FLAGS) ./cmd/nsd
		@go install -mod=readonly $(BUILD_FLAGS) ./cmd/nscli

go.sum: go.mod
		@echo "--> Ensure dependencies have not been modified"
		GO111MODULE=on go mod verify

test:
	@go test -mod=readonly $(PACKAGES)
```

包括 Ledger Nano 的支持怎么样？这需要一些小的改变:

*   创建一个包含以下内容的文件`Makefile.ledger`:

```
LEDGER_ENABLED ?= true

build_tags =
ifeq ($(LEDGER_ENABLED),true)
  ifeq ($(OS),Windows_NT)
    GCCEXE = $(shell where gcc.exe 2> NUL)
    ifeq ($(GCCEXE),)
      $(error gcc.exe not installed for ledger support, please install or set LEDGER_ENABLED=false)
    else
      build_tags += ledger
    endif
  else
    UNAME_S = $(shell uname -s)
    ifeq ($(UNAME_S),OpenBSD)
      $(warning OpenBSD detected, disabling ledger support (https://github.com/cosmos/cosmos-sdk/issues/1988))
    else
      GCC = $(shell command -v gcc 2> /dev/null)
      ifeq ($(GCC),)
        $(error gcc not installed for ledger support, please install or set LEDGER_ENABLED=false)
      else
        build_tags += ledger
      endif
    endif
  endif
endif
```

*   在 Makefile 的开头添加`include Makefile.ledger`:

```
LEDGER_ENABLED ?= true

build_tags =
ifeq ($(LEDGER_ENABLED),true)
  ifeq ($(OS),Windows_NT)
    GCCEXE = $(shell where gcc.exe 2> NUL)
    ifeq ($(GCCEXE),)
      $(error gcc.exe not installed for ledger support, please install or set LEDGER_ENABLED=false)
    else
      build_tags += ledger
    endif
  else
    UNAME_S = $(shell uname -s)
    ifeq ($(UNAME_S),OpenBSD)
      $(warning OpenBSD detected, disabling ledger support (https://github.com/cosmos/cosmos-sdk/issues/1988))
    else
      GCC = $(shell command -v gcc 2> /dev/null)
      ifeq ($(GCC),)
        $(error gcc not installed for ledger support, please install or set LEDGER_ENABLED=false)
      else
        build_tags += ledger
      endif
    endif
  endif
endif
```

**T2`go.mod`**

Golang 有一些依赖管理工具。在本教程中，您将使用 [`Go Modules`](https://github.com/golang/go/wiki/Modules) 。`Go Modules`在存储库的根中使用一个`go.mod`文件来定义应用程序需要什么依赖关系。Cosmos SDK 应用程序目前依赖于一些库的特定版本。下面的清单包含所有必需的版本。要开始，用下面的`constraints`和`overrides`替换`./go.mod`文件的内容:

> *注意*:如果你在你自己的回购中跟随，你将需要改变模块路径来反映它(`github.com/{ .Username }/{ .Project.Repo }`)。

*   你必须运行`go get ./...`来获取应用程序正在使用的所有模块。该命令将获得在`go.mod`文件中声明的依赖版本。
*   如果你想使用一个依赖的特定版本，那么你必须运行`go get github.com/<github_org>/<repo_name>@<version>`

# 构建应用程序

将应用程序安装到您的$GOBIN 中

```
make install 
```

现在，您应该能够运行以下命令:

```
nsd help
nscli help 
```

恭喜你，你已经完成了你的域名服务申请！试试跑步和它互动吧！

## 跑休息路线

既然您已经测试了 CLI 查询和事务，那么是时候在 REST 服务器中测试同样的东西了。离开您之前运行的`nsd`,开始收集您的地址:

```
nscli keys show jack --address
nscli keys show alice --address 
```

现在是时候在另一个终端窗口中启动`rest-server`了:

```
nscli rest-server --chain-id namechain --trust-node 
```

然后，您可以构造并运行以下查询:

> 注意:请确保用您的密码和买家/所有者地址替换下面列出的地址！

获取 jack 的序列号和帐号，以构建以下请求:

```
curl -s http://localhost:1317/auth/accounts/$(nscli keys show jack -a) 
```

这应该会返回类似的输出:

```
{"type":"auth/Account","value":{"address":"cosmos127qa40nmq56hu27ae263zvfk3ey0tkapwk0gq6","coins":[{"denom":"jackCoin","amount":"1000"},{"denom":"nametoken","amount":"1010"}],"public_key":{"type":"tendermint/PubKeySecp256k1","value":"A9YxyEbSWzLr+IdK/PuMUYmYToKYQ3P/pM8SI1Bxx3wu"},"account_number":"0","sequence":"1"}} 
```

获取 alice 的序列号和帐号，以构建以下请求

```
curl -s http://localhost:1317/auth/accounts/$(nscli keys show alice -a) 
```

这应该会返回类似的输出:

```
{"type":"auth/Account","value":{"address":"cosmos1h7ztnf2zkf4558hdxv5kpemdrg3tf94hnpvgsl","coins":[{"denom":"aliceCoin","amount":"1000"},{"denom":"nametoken","amount":"980"}],"public_key":{"type":"tendermint/PubKeySecp256k1","value":"Avc7qwecLHz5qb1EKDuSTLJfVOjBQezk0KSPDNybLONJ"},"account_number":"1","sequence":"2"}} 
```

为 jack 购买另一个名称，首先创建原始事务

> **注意**:请确保针对您的特定环境专门处理此请求，并且“买方”和“发件人”应该是同一个地址

```
curl -XPOST -s http://localhost:1317/nameservice/names --data-binary '{"base_req":{"from":"'$(nscli keys show jack -a)'","chain_id":"namechain"},"name":"jack1.id","amount":"5nametoken","buyer":"'$(nscli keys show jack -a)'"}' > unsignedTx.json 
```

那就签了这份交易。在真实环境中，原始事务应该在客户端进行签名。此外，序列需要调整，这取决于爱丽丝的帐户查询显示了什么。

```
nscli tx sign unsignedTx.json --from jack --offline --chain-id namechain --sequence 1 --account-number 0 > signedTx.json 
```

最后，广播已签名的事务:

```
nscli tx broadcast signedTx.json 
```

这应该会返回类似的输出:

```
{ "height": "266", "txhash": "C041AF0CE32FBAE5A4DD6545E4B1F2CB786879F75E2D62C79D690DAE163470BC", "logs": [  {   "msg_index": "0",   "success": true,   "log": ""  } ],"gas_wanted":"200000", "gas_used": "41510", "tags": [  {   "key": "action",   "value": "buy_name"  } ]} 
```

为杰克刚买的那个名字设置数据。
注意:请确保针对您的特定环境专门处理此请求，并且“所有者”和“发件人”应该是同一个地址

```
curl -XPUT -s http://localhost:1317/nameservice/names --data-binary '{"base_req":{"from":"'$(nscli keys show jack -a)'","chain_id":"namechain"},"name":"jack1.id","value":"8.8.4.4","owner":"'$(nscli keys show jack -a)'"}' > unsignedTx.json 
```

这应该会返回类似的输出:

```
{"check_tx":{"gasWanted":"200000","gasUsed":"1242"},"deliver_tx":{"log":"Msg 0: ","gasWanted":"200000","gasUsed":"1352","tags":[{"key":"YWN0aW9u","value":"c2V0X25hbWU="}]},"hash":"B4DF0105D57380D60524664A2E818428321A0DCA1B6B2F091FB3BEC54D68FAD7","height":"26"} 
```

同样，我们需要签名并广播:

```
nscli tx sign unsignedTx.json --from jack --offline --chain-id namechain --sequence 2 --account-number 0 > signedTx.json
nscli tx broadcast signedTx.json 
```

查询刚刚设置的名称 jack 的值(应该是 8.8.4.4):

```
curl -s http://localhost:1317/nameservice/names/jack1.id 
```

在 whois 中查询 jack 刚买的名字:

```
curl -s http://localhost:1317/nameservice/names/jack1.id/whois 
```

这应该会返回类似的输出:

```
{"value":"8.8.8.8","owner":"cosmos127qa40nmq56hu27ae263zvfk3ey0tkapwk0gq6","price":[{"denom":"STAKE","amount":"10"}]} 
```

爱丽丝从杰克那里买了一个名字:

```
curl -XPOST -s http://localhost:1317/nameservice/names --data-binary '{"base_req":{"from":"'$(nscli keys show alice -a)'","chain_id":"namechain"},"name":"jack1.id","amount":"10nametoken","buyer":"'$(nscli keys show alice -a)'"}' > unsignedTx.json 
```

同样，我们需要签名和广播。根据对爱丽丝账户的查询，账号已更改为 1，序列现在为 2:

```
nscli tx sign unsignedTx.json --from alice --offline --chain-id namechain --sequence 2 --account-number 1 > signedTx.json
nscli tx broadcast signedTx.json 
```

这应该会返回类似的输出:

```
{ "height": "1515", "txhash": "C9DCC423E10E7E5E40A549057A4AA060DA6D6A885A394F6ED5C0E40AEE984A77", "logs": [  {   "msg_index": "0",   "success": true,   "log": ""  } ],"gas_wanted": "200000", "gas_used": "42375", "tags": [  {   "key": "action",   "value": "buy_name"  } ]} 
```

现在，爱丽丝不再需要她从杰克那里买的名字，因此删除了它。只有所有者可以删除该名称。因为她是一个，她可以删除她从杰克那里买的名字:

```
curl -XDELETE -s http://localhost:1317/nameservice/names --data-binary '{"base_req":{"from":"'$(nscli keys show alice -a)'","chain_id":"namechain"},"name":"jack1.id","owner":"'$(nscli keys show alice -a)'"}' > unsignedTx.json 
```

以及最后的时间标记和广播。账号还是 1，但是顺序改成了 3，根据爱丽丝账号的查询:

```
nscli tx sign unsignedTx.json --from alice --offline --chain-id namechain --sequence 3 --account-number 1 > signedTx.json
nscli tx broadcast signedTx.json 
```

在 whois 中查询 Alice 刚刚删除的名字:

```
curl -s http://localhost:1317/nameservice/names/jack1.id/whois 
```

```
{"value":"","owner":"","price":[{"denom":"STAKE","amount":"1"}]} 
```

## 请求模式

**发布/名称服务/名称购买名称请求正文:**

```
{
  "base_req": {
    "name": "string",
    "chain_id": "string",
    "gas": "string,not_req",
    "gas_adjustment": "string,not_req",
  },
  "name": "string",
  "amount": "string",
  "buyer": "string"
}
```

**PUT/name service/names set name 请求正文:**

```
{
  "base_req": {
    "name": "string",
    "chain_id": "string",
    "gas": "string,not_req",
    "gas_adjustment": "strin,not_reqg"
  },
  "name": "string",
  "value": "string",
  "owner": "string"
}
```

**删除/名称服务/名称删除名称请求正文:**

```
{
  "base_req": {
    "name": "string",
    "chain_id": "string",
    "gas": "string,not_req",
    "gas_adjustment": "strin,not_reqg"
  },
  "name": "string",
  "owner": "string"
}

```

# 结论

恭喜你，你现在有一个运行在 Cosmos 上的名称服务应用程序了！