# cosmos/build-a-scavenger-game-1

> 原文：<https://github.com/figment-networks/learn-tutorials/blob/master/cosmos/build-a-scavenger-game-1.md>

[原版教程可以在这里的 Cosmos SDK 文档中找到](https://tutorials.cosmos.network/scavenge/tutorial/01-background.html)。

本次会议的目标是让你思考，在开发应用程序时，以原始的访问**数字稀缺性有什么可能。把稀缺性想成货币是最简单的方法；如果钱长在树上，它将不再稀缺，不再有价值。我们有处理金钱的软件的悠久历史，但是它从来没有成为编程环境中的一等公民。相反，货币总是被表示为一个数字或一个浮点数，这取决于第三方商家服务或其他一些交换过程，其中货币的*表示*被交换为实际的现金。如果金钱是软件环境中的一种原始元素，它将允许游戏和应用程序中存在实体经济，进一步消除游戏、生活和娱乐之间的界限。**

我们今天将使用一个名为 [Cosmos SDK](https://github.com/cosmos/cosmos-sdk) 的 Golang 框架。这个框架使得构建**确定性状态机**变得容易。状态机只是一个应用程序，它有一个状态和更新该状态的显式函数。你可以把一个灯泡和一个电灯开关想象成一种状态机:“应用”的状态要么是`light on`要么是`light off`。这个状态机有一个功能:`flip switch`。每次你触发`flip switch`，应用程序的状态就会从`light on`变为`light off`，反之亦然。简单吧？ ![](img/cc9ac46c7816c3d328c12afbc6859b38.png)

一个**确定性的**状态机仅仅是这样一个状态机，其中一系列的动作，放在一起并重放，将会有相同的结果。因此，如果我们将整个一月的所有`switch on`和`switch off`动作用于某个空间，然后在八月重放，我们应该有相同的`light on`或`light off`最终状态。一月或八月应该没有什么会改变结果(当然，如果在那段时间发生了电力短缺或维护之类的事情，一个真正的房间可能不是确定的)。

确定性状态机的好处在于，你可以用状态的**加密哈希**来跟踪变化，就像`git`这样的版本控制系统一样。如果对某个状态的散列有一致意见，就没有必要重放来自 genesis 的每个动作来确保两个 repos 彼此同步。当处理由许多不同的人在许多不同的情况下运行的软件时，这些属性很有用，就像 git 一样。

加密散列状态的另一个好特性是它创建了一个由**可靠依赖**组成的系统。我可以构建使用你的库的软件，并在你的软件中引用一个特定的状态。这样，如果你以破坏我的代码的方式更改你的代码，我就不必使用你的新版本，而是可以继续使用我引用的版本。这种确切了解系统状态(以及状态更新的所有方式)的相同属性，使得在应用程序中实现数字稀缺性的必要保证成为可能。*如果我说在一个状态机中某些东西只有一个，而你知道这个状态机不可能创建多个，你可以相信总是只有一个。*![](img/227b2f2ab3c0ec33b2cd7c3d783dcdf8.png)

现在你可能已经猜到我真正在谈论的是区块链。这些是确定性的状态机，对于状态如何更新有非常具体的规则。他们用加密散列检查状态，并使用非对称加密来处理**访问控制**。不同的区块链人有不同的方式来决定谁可以成为州检查站。这些实体可以被称为**验证器**。其中一些是由一个名为**工作证明**的电力密集型游戏选出的，与比特币或以太坊等区块链的最长链规则或**中本聪共识**相结合。

我们正在构建的状态机将使用一个名为 **Tendermint** 的 **proof-of-stake** 实现，它是节能的，可以由一个或多个验证器组成，可以是可信的，也可以是拜占庭式的。当建立一个处理*真实*稀缺的系统时，系统的完整性变得非常重要。确保完整性的一个方法是与一大群独立的参与者作为验证者来分担维护完整性的责任。

所以，现在我们知道了更多关于**为什么**我们可能会建立这样一个应用程序，让我们深入到游戏本身。

# 游戏

我们今天构建的应用程序可以有许多不同的用途，但我将把它称为**寻宝游戏**。寻宝游戏是指有人设置任务或问题，挑战参与者找到答案，并获得某种奖励。游戏的基本机制如下:

*   任何人都可以发布带有加密答案的问题。
*   这个问题伴随着大量的硬币。
*   任何人都可以发布这个问题的答案，如果答对了，他们将获得奖励硬币。

这里需要注意的是，在处理有延迟的公共网络时，可能会发生类似于[中间人攻击](https://en.wikipedia.org/wiki/Man-in-the-middle_attack)的情况。攻击者不是伪装成某一方，而是从某一方获取敏感信息，并将其用于自己的利益。这实际上被称为[前跑](https://en.wikipedia.org/wiki/Front_running)，其发生过程如下:

1.  你发布了某个问题的答案，并获得了奖金。
2.  其他人看到你发布了答案，他们就在你面前发布。
3.  因为是他们先贴出答案，所以是他们而不是你领取奖励。

为了防止抢先运行，我们将实现一个**提交-显示**方案。提交-揭示方案将单个可利用的交互转换成两个安全的交互。

**第一个交互是提交**。这是你“承诺”在后续互动中发布答案的地方。该提交由您的姓名的加密哈希和您认为正确的答案组成。应用程序保存这个值，这是一个声明，你知道答案，但尚未确认答案是否正确。

**下一个互动是展示**。在这里，你可以将答案和你的名字一起明文发布。该应用程序将采取你的答案和你的名字，并加密哈希它们。如果结果与您之前在提交阶段提交的结果相匹配，那么这将证明实际上是您知道答案，而不是有人抢在您前面。

![](img/349fbee503a5398b3d9965a6a56899e7.png)

像这样的系统可以以一种**不可信的**方式与任何类型的游戏平台串联使用。想象一下，你正在玩塞尔达传说，这个游戏已经包含了不同寻宝游戏的所有答案。当你到达一个关卡时，游戏会显示秘密答案。然后，无论是显式的还是幕后的，这个答案可能会与你的名字结合，被散列，提交，随后被披露。你的名字会得到奖励，你会在游戏中得到更多的分数。

实现这一点的另一种方法是拥有一个访问控制列表，其中有一个视频游戏公司控制的管理员帐户。这个管理帐户可以确认你击败的水平，然后给你点。这样做的问题是，它创建了* **单点故障**和试图攻击系统的单一目标。如果有一把钥匙控制着城堡，那么如果这把钥匙被泄露，整个系统就会崩溃。如果为了让玩家得到他们的分数，管理员帐号必须一直在线，这也产生了一个协调问题。如果你使用提交展示系统，那么你会有一个更不可信的架构，在那里你不需要许可就可以玩。这种设计决策有好处也有缺点，但是配合谨慎的实现，它可以让您的游戏在没有单一瓶颈或故障点的情况下扩展。

现在我们知道我们在构建什么，我们可以开始了。

# 脚手架

我们将使用一个叫做[脚手架](https://github.com/cosmos/scaffold)的工具来帮助我们快速构建一个样板应用。使用`scaffold`首先克隆并安装在你的本地机器上:

```js
git clone git@github.com:cosmos/scaffold.git
cd scaffold
make tools
make install
scaffold --help 
```

之后，您应该会看到显示以下帮助屏幕:

```js
This CLI helps in scaffolding out CosmosSDK based applications

Usage:
  scaffold [command]

Available Commands:
  app         Generates an empty application boilerplate
  help        Help about any command
  module      Generate an empty module for use in the Cosmos-SDK
  tutorial    Generates one of the tutorial apps, currently either the 'nameservice' or 'hellochain'

Flags:
  -c, --config string        config file (default is $HOME/.scaffold.yaml)
  -h, --help                 help for scaffold
  -o, --output-path string   Path to output
  -t, --toggle               Help message for toggle

Use "scaffold [command] --help" for more information about a command. 
```

现在你有了可用的`scaffold`命令，试着通过输入`scaffold app --help`来查看`app`命令的帮助屏幕。

```js
Generates an empty application boilerplate

Usage:
  scaffold app [lvl] [user] [repo] [flags]

Flags:
  -h, --help   help for app

Global Flags:
  -c, --config string        config file (default is $HOME/.scaffold.yaml)
  -o, --output-path string   Path to output 
```

我们将使用这个命令来生成一个基本的样板应用程序。首先在您的机器上创建一个新的工作目录，您可以用它来启动一个新项目。您可能想在您的主目录中使用`cd ~`来完成这项工作。在哪里并不重要，但是你可能不想呆在你的`scaffold`目录中。

当使用`scaffold app`命令启动项目时，参数`lvl`应该用`lvl-1`填充(这是目前唯一可用的 lvl)。你应该为`user`使用你自己的 github 用户名，并为`repo`想一个名字。在本教程中，我将使用`scavenge`作为回购名称。使用我自己的 github 句柄(`okwme`)最终的命令应该是这样的:

```js
scaffold app lvl-1 okwme scavenge 
```

这应该会在当前工作目录中名为`scavenge`的目录下生成一个文件夹结构。现在我们有了一个应用程序样板，我们想给它添加一些自定义功能，并构建我们的清除模块。用`cd scavenge/x`切换到模块目录。现在你可以运行`scaffold`工具的`module`命令，但是先用`scaffold module --help`查看一下它的帮助屏幕:

```js
Generate an empty module for use in the Cosmos-SDK

Usage:
  scaffold module [user] [repo] [moduleName] [flags]

Flags:
  -h, --help   help for module

Global Flags:
  -c, --config string        config file (default is $HOME/.scaffold.yaml)
  -o, --output-path string   Path to output 
```

同样，它要求您输入 github 用户名`user`和名称存储库名称`repo`。它还要求您为这个新模块命名。我也将为这个模块使用`scavenge`这个名字。

```js
scaffold module okwme scavenge scavenge 
```

既然我们已经用样板文件模块生成了样板文件应用程序，我们的下一步将是定义我们的消息。

# 信息

构建模块时，消息是一个很好的起点，因为它们定义了应用程序可以执行的操作。想象一下用户能够以任何方式更新应用程序状态的所有场景。这些应该归结为基本的交互，类似于 **CRUD** (创建、读取、更新、删除)。

让我们从**创建**开始

## MsgCreateScavenge

消息是位于`./x/scavenge/types/`目录中的`types`。已经有一个`msg.go`文件，但我们将为每种消息类型创建一个新文件。我们可以以`msg.go`为起点，将其重命名为`MsgCreateScavenge.go`，如下所示(假设您当前的工作目录是您的应用程序的根目录):

```js
mv ./x/scavenge/types/msg.go  ./x/scavenge/types/MsgCreateScavenge.go 
```

在这个新文件中，我们将取消注释，并遵循重命名变量的说明，直到它看起来如下:

```js
package types

import (
	sdk "github.com/cosmos/cosmos-sdk/types"
	sdkerrors "github.com/cosmos/cosmos-sdk/types/errors"
)

// MsgCreateScavenge
// ------------------------------------------------------------------------------
var _ sdk.Msg = &MsgCreateScavenge{}

// MsgCreateScavenge - struct for unjailing jailed validator
type MsgCreateScavenge struct {
	Creator      sdk.AccAddress `json:"creator" yaml:"creator"`           // address of the scavenger creator
	Description  string         `json:"description" yaml:"description"`   // description of the scavenge
	SolutionHash string         `json:"solutionHash" yaml:"solutionHash"` // solution hash of the scavenge
	Reward       sdk.Coins      `json:"reward" yaml:"reward"`             // reward of the scavenger
}

// NewMsgCreateScavenge creates a new MsgCreateScavenge instance
func NewMsgCreateScavenge(creator sdk.AccAddress, description, solutionHash string, reward sdk.Coins) MsgCreateScavenge {
	return MsgCreateScavenge{
		Creator:      creator,
		Description:  description,
		SolutionHash: solutionHash,
		Reward:       reward,
	}
}

// CreateScavengeConst is CreateScavenge Constant
const CreateScavengeConst = "CreateScavenge"

// nolint
func (msg MsgCreateScavenge) Route() string { return RouterKey }
func (msg MsgCreateScavenge) Type() string  { return CreateScavengeConst }
func (msg MsgCreateScavenge) GetSigners() []sdk.AccAddress {
	return []sdk.AccAddress{sdk.AccAddress(msg.Creator)}
}

// GetSignBytes gets the bytes for the message signer to sign on
func (msg MsgCreateScavenge) GetSignBytes() []byte {
	bz := ModuleCdc.MustMarshalJSON(msg)
	return sdk.MustSortJSON(bz)
}

// ValidateBasic validity check for the AnteHandler
func (msg MsgCreateScavenge) ValidateBasic() error {
	if msg.Creator.Empty() {
		return sdkerrors.Wrap(sdkerrors.ErrInvalidAddress, "creator can't be empty")
	}
	if msg.SolutionHash == "" {
		return sdkerrors.Wrap(sdkerrors.ErrInvalidRequest, "solutionScavengerHash can't be empty")
	}
	return nil
}
```

注意，应用中的所有消息都需要遵循`sdk.Msg`接口。消息`struct`包含创建新清除时的所有必要信息:

*   谁创造了它。这使用了`sdk.AccAddress`类型，它代表应用程序中由公钥加密控制的帐户。
*   `Description` -需要解决的问题或挑战的描述是什么。
*   `SolutionHash` -乱七八糟的解决方案。
*   这是奖励给最先提交答案的人的奖金。

`Msg`接口需要设置一些其他的方法，比如验证`struct`的内容，确认消息是由创建者签名并提交的。

既然我们可以创造一种清除剂，那么唯一的另一个必要行动就是能够解决它。如前所述，这应该分为两个独立的动作:`MsgCommitSolution`和`MsgRevealSolution`。

## MsgCommitSolution

该消息类型应位于`./x/scavenge/types/MsgCommitSolution.go`中，看起来像:

```js
package types

import (
	sdk "github.com/cosmos/cosmos-sdk/types"
	sdkerrors "github.com/cosmos/cosmos-sdk/types/errors"
)

// MsgCommitSolution
// ------------------------------------------------------------------------------
var _ sdk.Msg = &MsgCommitSolution{}

// MsgCommitSolution - struct for unjailing jailed validator
type MsgCommitSolution struct {
	Scavenger             sdk.AccAddress `json:"scavenger" yaml:"scavenger"`                         // address of the scavenger
	SolutionHash          string         `json:"solutionhash" yaml:"solutionhash"`                   // solutionhash of the scavenge
	SolutionScavengerHash string         `json:"solutionScavengerHash" yaml:"solutionScavengerHash"` // solution hash of the scavenge
}

// NewMsgCommitSolution creates a new MsgCommitSolution instance
func NewMsgCommitSolution(scavenger sdk.AccAddress, solutionHash string, solutionScavengerHash string) MsgCommitSolution {
	return MsgCommitSolution{
		Scavenger:             scavenger,
		SolutionHash:          solutionHash,
		SolutionScavengerHash: solutionScavengerHash,
	}
}

// CommitSolutionConst is CommitSolution Constant
const CommitSolutionConst = "CommitSolution"

// nolint
func (msg MsgCommitSolution) Route() string { return RouterKey }
func (msg MsgCommitSolution) Type() string  { return CommitSolutionConst }
func (msg MsgCommitSolution) GetSigners() []sdk.AccAddress {
	return []sdk.AccAddress{sdk.AccAddress(msg.Scavenger)}
}

// GetSignBytes gets the bytes for the message signer to sign on
func (msg MsgCommitSolution) GetSignBytes() []byte {
	bz := ModuleCdc.MustMarshalJSON(msg)
	return sdk.MustSortJSON(bz)
}

// ValidateBasic validity check for the AnteHandler
func (msg MsgCommitSolution) ValidateBasic() error {
	if msg.Scavenger.Empty() {
		return sdkerrors.Wrap(sdkerrors.ErrInvalidAddress, "creator can't be empty")
	}
	if msg.SolutionHash == "" {
		return sdkerrors.Wrap(sdkerrors.ErrInvalidRequest, "solutionHash can't be empty")
	}
	if msg.SolutionScavengerHash == "" {
		return sdkerrors.Wrap(sdkerrors.ErrInvalidRequest, "solutionScavengerHash can't be empty")
	}
	return nil
}
```

消息`struct`包含揭示解决方案的所有必要信息:

*   `Scavenger` -谁在揭示解决方案。
*   `SolutionHash` -加扰的解决方案(哈希)。
*   `SolutionScavengerHash` -这是解决方案和解决方案的人的组合的散列。

该消息也符合`sdk.Msg`接口。

## MsgRevealSolution

该消息类型应位于`./x/scavenge/types/MsgRevealSolution.go`中，看起来像:

```js
package types

import (
	"crypto/sha256"
	"encoding/hex"
	"fmt"

	sdk "github.com/cosmos/cosmos-sdk/types"
	sdkerrors "github.com/cosmos/cosmos-sdk/types/errors"
)

// MsgRevealSolution
// ------------------------------------------------------------------------------
var _ sdk.Msg = &MsgRevealSolution{}

// MsgRevealSolution - struct for unjailing jailed validator
type MsgRevealSolution struct {
	Scavenger    sdk.AccAddress `json:"scavenger" yaml:"scavenger"`       // address of the scavenger scavenger
	SolutionHash string         `json:"solutionHash" yaml:"solutionHash"` // SolutionHash of the scavenge
	Solution     string         `json:"solution" yaml:"solution"`         // solution of the scavenge
}

// NewMsgRevealSolution creates a new MsgRevealSolution instance
func NewMsgRevealSolution(scavenger sdk.AccAddress, solution string) MsgRevealSolution {

	var solutionHash = sha256.Sum256([]byte(solution))
	var solutionHashString = hex.EncodeToString(solutionHash[:])

	return MsgRevealSolution{
		Scavenger:    scavenger,
		SolutionHash: solutionHashString,
		Solution:     solution,
	}
}

// RevealSolutionConst is RevealSolution Constant
const RevealSolutionConst = "RevealSolution"

// nolint
func (msg MsgRevealSolution) Route() string { return RouterKey }
func (msg MsgRevealSolution) Type() string  { return RevealSolutionConst }
func (msg MsgRevealSolution) GetSigners() []sdk.AccAddress {
	return []sdk.AccAddress{sdk.AccAddress(msg.Scavenger)}
}

// GetSignBytes gets the bytes for the message signer to sign on
func (msg MsgRevealSolution) GetSignBytes() []byte {
	bz := ModuleCdc.MustMarshalJSON(msg)
	return sdk.MustSortJSON(bz)
}

// ValidateBasic validity check for the AnteHandler
func (msg MsgRevealSolution) ValidateBasic() error {
	if msg.Scavenger.Empty() {
		return sdkerrors.Wrap(sdkerrors.ErrInvalidAddress, "creator can't be empty")
	}
	if msg.SolutionHash == "" {
		return sdkerrors.Wrap(sdkerrors.ErrInvalidRequest, "solutionScavengerHash can't be empty")
	}
	if msg.Solution == "" {
		return sdkerrors.Wrap(sdkerrors.ErrInvalidRequest, "solutionHash can't be empty")
	}

	var solutionHash = sha256.Sum256([]byte(msg.Solution))
	var solutionHashString = hex.EncodeToString(solutionHash[:])

	if msg.SolutionHash != solutionHashString {
		return sdkerrors.Wrap(sdkerrors.ErrInvalidRequest, fmt.Sprintf("Hash of solution (%s) doesn't equal solutionHash (%s)", msg.SolutionHash, solutionHashString))
	}
	return nil
}
```

消息`struct`包含揭示解决方案的所有必要信息:

*   `Scavenger` -谁在揭示解决方案。
*   `SolutionHash` -乱七八糟的解决方案。
*   这是解决方案的纯文本版本。

该消息也符合`sdk.Msg`接口。

# 多媒体数字信号编解码器

一旦我们定义了我们的消息，我们需要向我们的编码器描述它们应该如何被存储为字节。为此，我们编辑位于`./x/scavenge/types/codec.go`的文件。通过如下描述我们的类型，它们将与我们的编码库一起工作:

```js
package types

import (
	"github.com/cosmos/cosmos-sdk/codec"
)

// RegisterCodec registers concrete types on codec
func RegisterCodec(cdc *codec.Codec) {
	cdc.RegisterConcrete(MsgCreateScavenge{}, "scavenge/CreateScavenge", nil)
	cdc.RegisterConcrete(MsgCommitSolution{}, "scavenge/CommitSolution", nil)
	cdc.RegisterConcrete(MsgRevealSolution{}, "scavenge/RevealSolution", nil)
}

// ModuleCdc defines the module codec
var ModuleCdc *codec.Codec

func init() {
	ModuleCdc = codec.New()
	RegisterCodec(ModuleCdc)
	codec.RegisterCrypto(ModuleCdc)
	ModuleCdc.Seal()
}
```

# 别名

现在我们有了这些新的消息类型，我们希望确保模块的其他部分可以访问它们。为此，我们使用了`./x/scavenge/alias.go`文件。这将从嵌套的`types`目录中导入类型，并使它们可以在模块顶层目录中访问。

```js
package scavenge

import (
	"github.com/cosmos/sdk-tutorials/scavenge/x/scavenge/keeper"
	"github.com/cosmos/sdk-tutorials/scavenge/x/scavenge/types"
)

const (
	ModuleName        = types.ModuleName
	RouterKey         = types.RouterKey
	StoreKey          = types.StoreKey
	DefaultParamspace = types.DefaultParamspace
	// QueryParams       = types.QueryParams
	QuerierRoute = types.QuerierRoute
)

var (
	// functions aliases
	NewKeeper           = keeper.NewKeeper
	NewQuerier          = keeper.NewQuerier
	RegisterCodec       = types.RegisterCodec
	NewGenesisState     = types.NewGenesisState
	DefaultGenesisState = types.DefaultGenesisState
	ValidateGenesis     = types.ValidateGenesis

	// variable aliases
	ModuleCdc = types.ModuleCdc

	NewMsgCreateScavenge = types.NewMsgCreateScavenge
	NewMsgCommitSolution = types.NewMsgCommitSolution
	NewMsgRevealSolution = types.NewMsgRevealSolution
)

type (
	Keeper       = keeper.Keeper
	GenesisState = types.GenesisState
	Params       = types.Params

	MsgCreateScavenge = types.MsgCreateScavenge
	MsgCommitSolution = types.MsgCommitSolution
	MsgRevealSolution = types.MsgRevealSolution
)
```

有消息当然很好，但是我们需要一个地方来存储他们发送的信息。所有与这个模块相关的持久数据应该存在于模块的`Keeper`中。

接下来让我们为我们的清除模块制作一个`Keeper`。

# 饲养员

在使用了`scaffold`命令之后，你应该在`./x/scavenge/keeper/keeper.go`有一个样板文件`Keeper`。它包含一个基本保持器，引用基本功能，如`Set`、`Get`和`Delete`。

我们的管理员为我们的模块存储所有的数据。有时候一个模块会导入另一个模块的 keeper。这将允许在模块间共享和修改状态。因为我们在我们的模块中处理作为赏金的硬币，我们将需要访问`bank`模块的守护者(我们称之为`CoinKeeper`)。看看我们完成的`Keeper`，你可以看到`bank`门将的引用以及`Set`、`Get`和`Delete`是如何展开的:

```js
package keeper

import (
	"fmt"

	"github.com/tendermint/tendermint/libs/log"

	"github.com/cosmos/cosmos-sdk/codec"
	sdk "github.com/cosmos/cosmos-sdk/types"
	"github.com/cosmos/cosmos-sdk/x/bank"
	"github.com/cosmos/sdk-tutorials/scavenge/x/scavenge/types"
)

// Keeper of the scavenge store
type Keeper struct {
	CoinKeeper bank.Keeper
	storeKey   sdk.StoreKey
	cdc        *codec.Codec
}

// NewKeeper creates a scavenge keeper
func NewKeeper(coinKeeper bank.Keeper, cdc *codec.Codec, key sdk.StoreKey) Keeper {
	keeper := Keeper{
		CoinKeeper: coinKeeper,
		storeKey:   key,
		cdc:        cdc,
	}
	return keeper
}

// Logger returns a module-specific logger.
func (k Keeper) Logger(ctx sdk.Context) log.Logger {
	return ctx.Logger().With("module", fmt.Sprintf("x/%s", types.ModuleName))
}

// GetCommit returns the commit of a solution
func (k Keeper) GetCommit(ctx sdk.Context, solutionScavengerHash string) (types.Commit, error) {
	store := ctx.KVStore(k.storeKey)
	var commit types.Commit
	byteKey := []byte(types.CommitPrefix + solutionScavengerHash)
	err := k.cdc.UnmarshalBinaryLengthPrefixed(store.Get(byteKey), &commit)
	if err != nil {
		return commit, err
	}
	return commit, nil
}

// GetScavenge returns the scavenge information
func (k Keeper) GetScavenge(ctx sdk.Context, solutionHash string) (types.Scavenge, error) {
	store := ctx.KVStore(k.storeKey)
	var scavenge types.Scavenge
	byteKey := []byte(types.ScavengePrefix + solutionHash)
	err := k.cdc.UnmarshalBinaryLengthPrefixed(store.Get(byteKey), &scavenge)
	if err != nil {
		return scavenge, err
	}
	return scavenge, nil
}

// SetCommit sets a scavenge
func (k Keeper) SetCommit(ctx sdk.Context, commit types.Commit) {
	solutionScavengerHash := commit.SolutionScavengerHash
	store := ctx.KVStore(k.storeKey)
	bz := k.cdc.MustMarshalBinaryLengthPrefixed(commit)
	key := []byte(types.CommitPrefix + solutionScavengerHash)
	store.Set(key, bz)
}

// SetScavenge sets a scavenge
func (k Keeper) SetScavenge(ctx sdk.Context, scavenge types.Scavenge) {
	solutionHash := scavenge.SolutionHash
	store := ctx.KVStore(k.storeKey)
	bz := k.cdc.MustMarshalBinaryLengthPrefixed(scavenge)
	key := []byte(types.ScavengePrefix + solutionHash)
	store.Set(key, bz)
}

// DeleteScavenge deletes a scavenge
func (k Keeper) DeleteScavenge(ctx sdk.Context, solutionHash string) {
	store := ctx.KVStore(k.storeKey)
	store.Delete([]byte(solutionHash))
}

// GetScavengesIterator gets an iterator over all scavnges in which the keys are the solutionHashes and the values are the scavenges
func (k Keeper) GetScavengesIterator(ctx sdk.Context) sdk.Iterator {
	store := ctx.KVStore(k.storeKey)
	return sdk.KVStorePrefixIterator(store, []byte(types.ScavengePrefix))
}

// GetCommitsIterator gets an iterator over all commits in which the keys are the prefix and solutionHashes and the values are the scavenges
func (k Keeper) GetCommitsIterator(ctx sdk.Context) sdk.Iterator {
	store := ctx.KVStore(k.storeKey)
	return sdk.KVStorePrefixIterator(store, []byte(types.CommitPrefix))
}
```

## 提交和清除

你可能会注意到在整个`Keeper`中对`types.Commit`和`types.Scavenge`的引用。这些是在`./x/scavenge/types/types.go`中定义的新结构，包含了关于不同清除挑战的所有必要信息，以及针对这些挑战的不同承诺解决方案。它们看起来与我们之前看到的`Msg`类型相似，因为它们包含相似的信息。您现在可以创建该文件并添加以下内容:

```js
package types

import (
	"fmt"
	"strings"

	sdk "github.com/cosmos/cosmos-sdk/types"
)

// Scavenge is the Scavenge struct
type Scavenge struct {
	Creator      sdk.AccAddress `json:"creator" yaml:"creator"`           // address of the scavenger creator
	Description  string         `json:"description" yaml:"description"`   // description of the scavenge
	SolutionHash string         `json:"solutionHash" yaml:"solutionHash"` // solution hash of the scavenge
	Reward       sdk.Coins      `json:"reward" yaml:"reward"`             // reward of the scavenger
	Solution     string         `json:"solution" yaml:"solution"`         // the solution to the scagenve
	Scavenger    sdk.AccAddress `json:"scavenger" yaml:"scavenger"`       // the scavenger who found the solution
}

// implement fmt.Stringer
func (s Scavenge) String() string {
	return strings.TrimSpace(fmt.Sprintf(`Creator: %s
 Description: %s
 SolutionHash: %s
 Reward: %s
 Solution: %s
 Scavenger: %s`,
		s.Creator,
		s.Description,
		s.SolutionHash,
		s.Reward,
		s.Solution,
		s.Scavenger,
	))
}

// Commit is the commit struct
type Commit struct {
	Scavenger             sdk.AccAddress `json:"scavenger" yaml:"scavenger"`                         // address of the scavenger scavenger
	SolutionHash          string         `json:"solutionHash" yaml:"solutionHash"`                   // SolutionHash of the scavenge
	SolutionScavengerHash string         `json:"solutionScavengerHash" yaml:"solutionScavengerHash"` // solution hash of the scavenge
}

// implement fmt.Stringer
func (c Commit) String() string {
	return strings.TrimSpace(fmt.Sprintf(`Scavenger: %s
 SolutionHash: %s
 SolutionScavengerHash: %s`,
		c.Scavenger,
		c.SolutionHash,
		c.SolutionScavengerHash,
	))
}
```

您可以想象一个未解决的`Scavenge`在被解决之前会包含字段`Solution`和`Scavenger`的`nil`值。您可能还会注意到，每种类型都有`String`方法。这允许我们将该结构呈现为用于呈现的字符串。

## 前缀

你可能会注意到`types.ScavengePrefix`和`types.CommitPrefix`的用法。这些被定义在一个叫做`./x/scavenge/types/key.go`的文件中，帮助我们保持我们的`Keeper`有组织。`Keeper`实际上只是一个关键价值商店。这意味着，与 javascript 中的`Object`类似，所有值都在一个键下被引用。要访问一个值，您需要知道存储它的键。这有点像唯一标识符(UID)。

当存储一个`Scavenge`时，我们使用`SolutionHash`的密钥作为唯一 ID，对于一个`Commit`，我们使用`SolutionScavengeHash`的密钥。然而，由于我们将这两种数据类型存储在同一个位置，我们可能希望区分我们用作键的散列类型。我们可以通过在哈希中添加前缀来做到这一点，这样我们就可以识别出哪个是哪个。对于`Scavenge`，我们添加前缀`sk-`，对于`Commit`，我们添加前缀`ck-`。您应该将这些添加到您的`key.go`文件中，如下所示:

```js
package types

const (
	// ModuleName is the name of the module
	ModuleName = "scavenge"

	// StoreKey to be used when creating the KVStore
	StoreKey = ModuleName

	// RouterKey to be used for routing msgs
	RouterKey = ModuleName

	QuerierRoute = ModuleName

	ScavengePrefix = "sk-"
	CommitPrefix   = "ck-"
)
```

copy package types const(//ModuleName 是创建 kv store store key = ModuleName//router key 以用于路由 msgs router key = ModuleName querier route = ModuleName scavenger prefix = " sk-" commit prefix = " CK-")时要使用的模块的名称

## 迭代程序

有时你会想通过键直接访问一个`Commit`或者一个`Scavenge`。这就是为什么我们有方法`GetCommit`和`GetScavenge`。然而，有时你会想一次得到所有的`Scavenge`或者一次得到所有的`Commit`。为此，我们使用一个名为`KVStorePrefixIterator`的**迭代器**。这个实用程序来自于`sdk`并遍历一个密钥库。如果您提供了前缀，它将只迭代包含该前缀的键。因为我们已经为我们的`Scavenge`和`Commit`定义了前缀，所以我们可以在这里使用它们只返回我们想要的数据类型。

既然您已经看到了存储每个`Commit`和`Scavenge`的`Keeper`，我们需要将消息连接到这个存储器。这个过程被称为*处理*消息，并且在`Handler`内部完成。

# 处理者

为了让**消息**到达**保持器**，它必须通过**处理器**。这就是可以应用逻辑来允许或拒绝`Message`成功的地方。这也是状态应该如何在保持器中改变的逻辑应该发生的地方。如果你熟悉[模型视图控制器](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller) (MVC)架构，那么`Keeper`有点像**模型**，`Handler`有点像**控制器**。如果你熟悉 [React/Redux](https://en.wikipedia.org/wiki/React_%28web_framework%29) 或 [Vue/Vuex](https://en.wikipedia.org/wiki/Vue.js) 架构，那么`Keeper`有点像**减速器/存储**而`Handler`有点像**动作**。

我们的处理程序将进入`./x/scavenge/handler.go`并遵循样板文件中概述的建议。我们将为我们的三个`Message`、`MsgCreateScavenge`、`MsgCommitSolution`和`MsgRevealSolution`类型分别创建处理函数，直到文件如下所示:

```js
package scavenge

import (
	"crypto/sha256"
	"encoding/hex"
	"fmt"

	sdk "github.com/cosmos/cosmos-sdk/types"
	sdkerrors "github.com/cosmos/cosmos-sdk/types/errors"
	"github.com/cosmos/sdk-tutorials/scavenge/x/scavenge/types"
	"github.com/tendermint/tendermint/crypto"
)

// NewHandler creates an sdk.Handler for all the scavenge type messages
func NewHandler(k Keeper) sdk.Handler {
	return func(ctx sdk.Context, msg sdk.Msg) (*sdk.Result, error) {
		ctx = ctx.WithEventManager(sdk.NewEventManager())
		switch msg := msg.(type) {
		case MsgCreateScavenge:
			return handleMsgCreateScavenge(ctx, k, msg)
		case MsgCommitSolution:
			return handleMsgCommitSolution(ctx, k, msg)
		case MsgRevealSolution:
			return handleMsgRevealSolution(ctx, k, msg)
		default:
			return nil, sdkerrors.Wrap(sdkerrors.ErrUnknownRequest,
				fmt.Sprintf("unrecognized %s message type: %T", types.ModuleName, msg))
		}
	}
}

// handleMsgCreateScavenge creates a new scavenge and moves the reward into escrow
func handleMsgCreateScavenge(ctx sdk.Context, k Keeper, msg MsgCreateScavenge) (*sdk.Result, error) {
	var scavenge = types.Scavenge{
		Creator:      msg.Creator,
		Description:  msg.Description,
		SolutionHash: msg.SolutionHash,
		Reward:       msg.Reward,
	}
	_, err := k.GetScavenge(ctx, scavenge.SolutionHash)
	if err == nil {
		return nil, sdkerrors.Wrap(sdkerrors.ErrInvalidRequest, "Scavenge with that solution hash already exists")
	}
	moduleAcct := sdk.AccAddress(crypto.AddressHash([]byte(types.ModuleName)))
	sdkError := k.CoinKeeper.SendCoins(ctx, scavenge.Creator, moduleAcct, scavenge.Reward)
	if sdkError != nil {
		return nil, sdkError
	}
	k.SetScavenge(ctx, scavenge)
	ctx.EventManager().EmitEvent(
		sdk.NewEvent(
			sdk.EventTypeMessage,
			sdk.NewAttribute(sdk.AttributeKeyModule, types.AttributeValueCategory),
			sdk.NewAttribute(sdk.AttributeKeyAction, types.EventTypeCreateScavenge),
			sdk.NewAttribute(sdk.AttributeKeySender, msg.Creator.String()),
			sdk.NewAttribute(types.AttributeDescription, msg.Description),
			sdk.NewAttribute(types.AttributeSolutionHash, msg.SolutionHash),
			sdk.NewAttribute(types.AttributeReward, msg.Reward.String()),
		),
	)
	return &sdk.Result{Events: ctx.EventManager().Events()}, nil
}

func handleMsgCommitSolution(ctx sdk.Context, k Keeper, msg MsgCommitSolution) (*sdk.Result, error) {
	var commit = types.Commit{
		Scavenger:             msg.Scavenger,
		SolutionHash:          msg.SolutionHash,
		SolutionScavengerHash: msg.SolutionScavengerHash,
	}
	_, err := k.GetCommit(ctx, commit.SolutionScavengerHash)
	// should produce an error when commit is not found
	if err == nil {
		return nil, sdkerrors.Wrap(sdkerrors.ErrInvalidRequest, "Commit with that hash already exists")
	}
	k.SetCommit(ctx, commit)
	ctx.EventManager().EmitEvent(
		sdk.NewEvent(
			sdk.EventTypeMessage,
			sdk.NewAttribute(sdk.AttributeKeyModule, types.AttributeValueCategory),
			sdk.NewAttribute(sdk.AttributeKeyAction, types.EventTypeCommitSolution),
			sdk.NewAttribute(sdk.AttributeKeySender, msg.Scavenger.String()),
			sdk.NewAttribute(types.AttributeSolutionHash, msg.SolutionHash),
			sdk.NewAttribute(types.AttributeSolutionScavengerHash, msg.SolutionScavengerHash),
		),
	)
	return &sdk.Result{Events: ctx.EventManager().Events()}, nil
}

func handleMsgRevealSolution(ctx sdk.Context, k Keeper, msg MsgRevealSolution) (*sdk.Result, error) {
	var solutionScavengerBytes = []byte(msg.Solution + msg.Scavenger.String())
	var solutionScavengerHash = sha256.Sum256(solutionScavengerBytes)
	var solutionScavengerHashString = hex.EncodeToString(solutionScavengerHash[:])
	_, err := k.GetCommit(ctx, solutionScavengerHashString)
	if err != nil {
		return nil, sdkerrors.Wrap(err, "Commit with that hash doesn't exists")
	}

	var solutionHash = sha256.Sum256([]byte(msg.Solution))
	var solutionHashString = hex.EncodeToString(solutionHash[:])
	var scavenge types.Scavenge
	scavenge, err = k.GetScavenge(ctx, solutionHashString)
	if err != nil {
		return nil, sdkerrors.Wrap(err, "Scavenge with that solution hash doesn't exists")
	}
	if scavenge.Scavenger != nil {
		return nil, sdkerrors.Wrap(sdkerrors.ErrInvalidRequest, "Scavenge has already been solved")
	}
	scavenge.Scavenger = msg.Scavenger
	scavenge.Solution = msg.Solution

	moduleAcct := sdk.AccAddress(crypto.AddressHash([]byte(types.ModuleName)))
	sdkError := k.CoinKeeper.SendCoins(ctx, moduleAcct, scavenge.Scavenger, scavenge.Reward)
	if sdkError != nil {
		return nil, sdkError
	}
	k.SetScavenge(ctx, scavenge)
	ctx.EventManager().EmitEvent(
		sdk.NewEvent(
			sdk.EventTypeMessage,
			sdk.NewAttribute(sdk.AttributeKeyModule, types.AttributeValueCategory),
			sdk.NewAttribute(sdk.AttributeKeyAction, types.EventTypeSolveScavenge),
			sdk.NewAttribute(sdk.AttributeKeySender, msg.Scavenger.String()),
			sdk.NewAttribute(types.AttributeSolutionHash, solutionHashString),
			sdk.NewAttribute(types.AttributeDescription, scavenge.Description),
			sdk.NewAttribute(types.AttributeSolution, msg.Solution),
			sdk.NewAttribute(types.AttributeScavenger, scavenge.Scavenger.String()),
			sdk.NewAttribute(types.AttributeReward, scavenge.Reward.String()),
		),
	)
	return &sdk.Result{Events: ctx.EventManager().Events()}, nil
}
```

## 模块 Acct

您可能会注意到在`handleMsgCreateScavenge`和`handleMsgRevealSolution`处理函数中使用了`moduleAcct`。该帐户不受公钥对的控制，而是对该实际模块所拥有的帐户的引用。它被用来保存一个拾荒者的赏金，直到这个拾荒者被解决，赏金将被支付给解决这个拾荒者的账户。

# 事件

在每个处理程序的末尾是一个`EventManager`,它将在事务中创建日志，揭示在处理这个消息的过程中发生了什么。这对于客户端软件来说很有用，因为客户端软件想知道状态转换的结果是什么。这些事件使用一系列可在`./x/scavenge/types/events.go`中找到的预定义类型，如下所示:

```js
package types

// scavenge module event types
const (
	EventTypeCreateScavenge = "CreateScavenge"
	EventTypeCommitSolution = "CommitSolution"
	EventTypeSolveScavenge  = "SolveScavenge"

	AttributeDescription           = "description"
	AttributeSolution              = "solution"
	AttributeSolutionHash          = "solutionHash"
	AttributeReward                = "reward"
	AttributeScavenger             = "scavenger"
	AttributeSolutionScavengerHash = "solutionScavengerHash"

	AttributeValueCategory = ModuleName
)
```

现在我们已经有了更新状态所需的所有信息(`Message`、`Handler`、`Keeper`)，我们可能要考虑如何让*查询*状态。这通常是通过 REST 端点和/或 CLI 来完成的。这两个客户端都与应用程序中查询状态的部分交互，称为`Querier`。

# 问题

为了查询我们应用程序的数据，我们需要使用我们的`Querier`来访问它。应用程序的这一部分与`Keeper`协同工作来访问状态并返回它。`Querier`在`./x/scavenge/keeper/querier.go`中定义。我们的`scaffold`工具以一些关于它应该看起来如何的建议开始，并且类似于我们的`Handler`我们想要处理不同的查询路线。对于许多不同类型的查询，您可以在`Querier`中创建许多不同的路径，但是我们将只创建三个:

*   `listScavenges`将列出所有拾荒者
*   `getScavenge`将在`solutionHash`之前获得一次清除
*   `getCommit`将在`solutionScavengerHash`之前获得一次提交

结合到一个 switch 语句中，并且每个函数都被充实，它应该如下所示:

```js
package keeper

import (
	abci "github.com/tendermint/tendermint/abci/types"

	"github.com/cosmos/cosmos-sdk/codec"
	sdk "github.com/cosmos/cosmos-sdk/types"
	sdkerrors "github.com/cosmos/cosmos-sdk/types/errors"
	"github.com/cosmos/sdk-tutorials/scavenge/x/scavenge/types"
)

// NewQuerier creates a new querier for scavenge clients.
func NewQuerier(k Keeper) sdk.Querier {
	return func(ctx sdk.Context, path []string, req abci.RequestQuery) ([]byte, error) {
		switch path[0] {
		case types.QueryListScavenges:
			return listScavenges(ctx, k)
		case types.QueryGetScavenge:
			return getScavenge(ctx, path[1:], k)
		case types.QueryCommit:
			return getCommit(ctx, path[1:], k)
		default:
			return nil, sdkerrors.Wrap(sdkerrors.ErrUnknownRequest, "unknown scavenge query endpoint")
		}
	}
}

// RemovePrefixFromHash removes the prefix from the key
func RemovePrefixFromHash(key []byte, prefix []byte) (hash []byte) {
	hash = key[len(prefix):]
	return hash
}

func listScavenges(ctx sdk.Context, k Keeper) ([]byte, error) {
	var scavengeList types.QueryResScavenges

	iterator := k.GetScavengesIterator(ctx)

	for ; iterator.Valid(); iterator.Next() {
		scavengeHash := RemovePrefixFromHash(iterator.Key(), []byte(types.ScavengePrefix))
		scavengeList = append(scavengeList, string(scavengeHash))
	}

	res, err := codec.MarshalJSONIndent(k.cdc, scavengeList)
	if err != nil {
		return res, sdkerrors.Wrap(sdkerrors.ErrJSONMarshal, err.Error())
	}

	return res, nil
}

func getScavenge(ctx sdk.Context, path []string, k Keeper) (res []byte, sdkError error) {
	solutionHash := path[0]
	scavenge, err := k.GetScavenge(ctx, solutionHash)
	if err != nil {
		return nil, err
	}

	res, err = codec.MarshalJSONIndent(k.cdc, scavenge)
	if err != nil {
		return nil, sdkerrors.Wrap(sdkerrors.ErrJSONMarshal, err.Error())
	}

	return res, nil
}

func getCommit(ctx sdk.Context, path []string, k Keeper) (res []byte, sdkError error) {
	solutionScavengerHash := path[0]
	commit, err := k.GetCommit(ctx, solutionScavengerHash)
	if err != nil {
		return nil, err
	}
	res, err = codec.MarshalJSONIndent(k.cdc, commit)
	if err != nil {
		return nil, sdkerrors.Wrap(sdkerrors.ErrJSONMarshal, err.Error())
	}
	return res, nil
}
```

## 类型

您可能会注意到，我们在初始 switch 语句中使用了三种不同的导入类型。这些在我们的`./x/scavenge/types/querier.go`文件中被定义为简单的字符串。该文件应该如下所示:

```js
package types

import "strings"

// query endpoints supported by the nameservice Querier
const (
	QueryListScavenges = "list"
	QueryGetScavenge   = "get"
	QueryCommit        = "commit"
)

// // QueryResResolve Queries Result Payload for a resolve query
// type QueryResResolve struct {
// 	Value string `json:"value"`
// }

// // implement fmt.Stringer
// func (r QueryResResolve) String() string {
// 	return r.Value
// }

// QueryResScavenges Queries Result Payload for a names query
type QueryResScavenges []string

// implement fmt.Stringer
func (n QueryResScavenges) String() string {
	return strings.Join(n[:], "\n")
}
```

我们的查询相当简单，因为我们已经为我们的`Keeper`配备了访问状态所需的所有函数。您可以看到这里也使用了迭代器。

既然我们已经创建了模块的所有基本操作，我们希望使它们可访问。我们可以用一个 CLI 客户机和一个 REST 客户机来做到这一点。在本教程中，我们将只创建一个 CLI 客户端。如果你对制作 REST 客户端感兴趣，可以看看[名称服务教程](https://tutorials.cosmos.network/nameservice/tutorial/00-intro.html)。

让我们来看看制作 CLI 需要什么。

# 硬币指示器 （coin-levelindicator 的缩写）命令行界面（Command Line Interface for batch scripting）

一旦应用程序在某个地方的机器上运行，命令行界面(CLI)将帮助我们与应用程序进行交互。每个模块在 CLI 中都有自己的命名空间，这使它能够创建和签名要由该模块处理的消息。它还具有查询该模块状态的能力。当与应用程序的其余部分结合使用时，CLI 将允许您为新帐户生成密钥或检查您已经与应用程序交互的状态。

我们模块的 CLI 被分成两个文件，名为`tx.go`和`query.go`，它们位于`./x/scavenge/client/cli/`。一个文件用于进行包含消息的事务，这些消息将最终更新我们的状态。另一个是进行查询，这将使我们能够从我们的状态中读取信息。这两个文件都利用了 [Cobra](https://github.com/spf13/cobra) 库。

## tx.go

`tx.go`文件包含`GetTxCmd`，这是 Cosmos SDK 中的一个标准方法。稍后在`module.go`文件中会引用它，该文件准确描述了一个模块所具有的属性。这使得在实际应用程序的层次上，由于不同的原因而合并不同的模块变得更加容易。毕竟，我们现在关注的是一个模块，但是稍后我们将创建一个应用程序，利用这个模块以及 Cosmos SDK 中已经可用的其他模块。

在`GetTxCmd`中，我们创建了一个新的特定于模块的命令，调用是`scavenge`。在这个命令中，我们为我们定义的每种消息类型添加了一个子命令:

*   `GetCmdCreateScavenge`
*   `GetCmdCommitSolution`
*   `GetCmdRevealSolution`

每个函数从 **Cobra** CLI 工具获取参数，创建新的消息，签名并提交给应用程序进行处理。这些函数应该放在`tx.go`文件中，如下所示:

```js
package cli

import (
	"bufio"
	"crypto/sha256"
	"encoding/hex"
	"fmt"

	"github.com/spf13/cobra"

	"github.com/cosmos/cosmos-sdk/client"
	"github.com/cosmos/cosmos-sdk/client/context"
	"github.com/cosmos/cosmos-sdk/client/flags"
	"github.com/cosmos/cosmos-sdk/codec"
	sdk "github.com/cosmos/cosmos-sdk/types"
	"github.com/cosmos/cosmos-sdk/x/auth"
	"github.com/cosmos/cosmos-sdk/x/auth/client/utils"
	"github.com/cosmos/sdk-tutorials/scavenge/x/scavenge/types"
)

// GetTxCmd returns the transaction commands for this module
func GetTxCmd(cdc *codec.Codec) *cobra.Command {
	scavengeTxCmd := &cobra.Command{
		Use:                        types.ModuleName,
		Short:                      fmt.Sprintf("%s transactions subcommands", types.ModuleName),
		DisableFlagParsing:         true,
		SuggestionsMinimumDistance: 2,
		RunE:                       client.ValidateCmd,
	}

	scavengeTxCmd.AddCommand(flags.PostCommands(
		GetCmdCreateScavenge(cdc),
		GetCmdCommitSolution(cdc),
		GetCmdRevealSolution(cdc),
	)...)

	return scavengeTxCmd
}

func GetCmdCreateScavenge(cdc *codec.Codec) *cobra.Command {
	return &cobra.Command{
		Use:   "createScavenge [reward] [solution] [description]",
		Short: "Creates a new scavenge with a reward",
		Args:  cobra.ExactArgs(3), // Does your request require arguments
		RunE: func(cmd *cobra.Command, args []string) error {

			cliCtx := context.NewCLIContext().WithCodec(cdc)
			inBuf := bufio.NewReader(cmd.InOrStdin())
			txBldr := auth.NewTxBuilderFromCLI(inBuf).WithTxEncoder(utils.GetTxEncoder(cdc))

			reward, err := sdk.ParseCoins(args[0])
			if err != nil {
				return err
			}

			var solution = args[1]
			var solutionHash = sha256.Sum256([]byte(solution))
			var solutionHashString = hex.EncodeToString(solutionHash[:])

			msg := types.NewMsgCreateScavenge(cliCtx.GetFromAddress(), args[2], solutionHashString, reward)
			err = msg.ValidateBasic()
			if err != nil {
				return err
			}

			return utils.GenerateOrBroadcastMsgs(cliCtx, txBldr, []sdk.Msg{msg})
		},
	}
}

func GetCmdCommitSolution(cdc *codec.Codec) *cobra.Command {
	return &cobra.Command{
		Use:   "commitSolution [solution]",
		Short: "Commits a solution for scavenge",
		Args:  cobra.ExactArgs(1), // Does your request require arguments
		RunE: func(cmd *cobra.Command, args []string) error {

			cliCtx := context.NewCLIContext().WithCodec(cdc)
			inBuf := bufio.NewReader(cmd.InOrStdin())
			txBldr := auth.NewTxBuilderFromCLI(inBuf).WithTxEncoder(utils.GetTxEncoder(cdc))

			var solution = args[0]
			var solutionHash = sha256.Sum256([]byte(solution))
			var solutionHashString = hex.EncodeToString(solutionHash[:])

			var scavenger = cliCtx.GetFromAddress().String()

			var solutionScavengerHash = sha256.Sum256([]byte(solution + scavenger))
			var solutionScavengerHashString = hex.EncodeToString(solutionScavengerHash[:])

			msg := types.NewMsgCommitSolution(cliCtx.GetFromAddress(), solutionHashString, solutionScavengerHashString)
			err := msg.ValidateBasic()
			if err != nil {
				return err
			}
			return utils.GenerateOrBroadcastMsgs(cliCtx, txBldr, []sdk.Msg{msg})
		},
	}
}

func GetCmdRevealSolution(cdc *codec.Codec) *cobra.Command {
	return &cobra.Command{
		Use:   "revealSolution [solution]",
		Short: "Reveals a solution for scavenge",
		Args:  cobra.ExactArgs(1), // Does your request require arguments
		RunE: func(cmd *cobra.Command, args []string) error {

			cliCtx := context.NewCLIContext().WithCodec(cdc)
			inBuf := bufio.NewReader(cmd.InOrStdin())
			txBldr := auth.NewTxBuilderFromCLI(inBuf).WithTxEncoder(utils.GetTxEncoder(cdc))

			var solution = args[0]

			msg := types.NewMsgRevealSolution(cliCtx.GetFromAddress(), solution)
			err := msg.ValidateBasic()
			if err != nil {
				return err
			}

			return utils.GenerateOrBroadcastMsgs(cliCtx, txBldr, []sdk.Msg{msg})
		},
	}
}
```

## sha256

注意，这个文件使用了`sha256`库来将我们的纯文本解决方案散列成混乱的散列。这种活动发生在客户端，因此解决方案绝不会泄露给任何公共实体，这些公共实体可能想要偷取高峰并窃取与拾荒者相关的赏金。您还可以注意到，散列被转换成十六进制表示形式，以便于作为字符串读取(这就是它们最终存储在 keeper 中的方式)。

## query.go

`query.go`文件包含类似的 **Cobra** 命令，这些命令为引用我们的`scavenge`模块保留了一个新的名称空间。然而，`query.go`文件不是创建和提交消息，而是创建查询并以人类可读的形式返回结果。它处理的查询与我们之前在`querier.go`文件中定义的相同:

*   `GetCmdListScavenges`
*   `GetCmdGetScavenge`
*   `GetCmdGetCommit`

定义这些命令后，您的`query.go`文件应该看起来像这样:

```js
package cli

import (
	"crypto/sha256"
	"encoding/hex"
	"fmt"

	"github.com/cosmos/cosmos-sdk/client"
	"github.com/cosmos/cosmos-sdk/client/context"
	"github.com/cosmos/cosmos-sdk/client/flags"
	"github.com/cosmos/cosmos-sdk/codec"
	"github.com/spf13/cobra"

	"github.com/cosmos/sdk-tutorials/scavenge/x/scavenge/types"
)

// GetQueryCmd returns the cli query commands for this module
func GetQueryCmd(queryRoute string, cdc *codec.Codec) *cobra.Command {
	// Group scavenge queries under a subcommand
	scavengeQueryCmd := &cobra.Command{
		Use:                        types.ModuleName,
		Short:                      fmt.Sprintf("Querying commands for the %s module", types.ModuleName),
		DisableFlagParsing:         true,
		SuggestionsMinimumDistance: 2,
		RunE:                       client.ValidateCmd,
	}

	scavengeQueryCmd.AddCommand(
		flags.GetCommands(
			GetCmdListScavenges(queryRoute, cdc),
			GetCmdGetScavenge(queryRoute, cdc),
			GetCmdGetCommit(queryRoute, cdc),
		)...,
	)

	return scavengeQueryCmd

}

func GetCmdListScavenges(queryRoute string, cdc *codec.Codec) *cobra.Command {
	return &cobra.Command{
		Use:   "list",
		Short: "list",
		// Args:  cobra.ExactArgs(1),
		RunE: func(cmd *cobra.Command, args []string) error {
			cliCtx := context.NewCLIContext().WithCodec(cdc)

			res, _, err := cliCtx.QueryWithData(fmt.Sprintf("custom/%s/"+types.QueryListScavenges, queryRoute), nil)
			if err != nil {
				fmt.Printf("could not get scavenges\n%s\n", err.Error())
				return nil
			}

			var out types.QueryResScavenges
			cdc.MustUnmarshalJSON(res, &out)
			return cliCtx.PrintOutput(out)
		},
	}
}
func GetCmdGetScavenge(queryRoute string, cdc *codec.Codec) *cobra.Command {
	return &cobra.Command{
		Use:   "get [solutionHash]",
		Short: "Query a scavenge by solutionHash",
		Args:  cobra.ExactArgs(1),
		RunE: func(cmd *cobra.Command, args []string) error {
			cliCtx := context.NewCLIContext().WithCodec(cdc)
			solutionHash := args[0]

			res, _, err := cliCtx.QueryWithData(fmt.Sprintf("custom/%s/%s/%s", queryRoute, types.QueryGetScavenge, solutionHash), nil)
			if err != nil {
				fmt.Printf("could not resolve scavenge %s \n%s\n", solutionHash, err.Error())

				return nil
			}

			var out types.Scavenge
			cdc.MustUnmarshalJSON(res, &out)
			return cliCtx.PrintOutput(out)
		},
	}
}
func GetCmdGetCommit(queryRoute string, cdc *codec.Codec) *cobra.Command {
	return &cobra.Command{
		Use:   "commited [solution] [scavenger]",
		Short: "Query a commit by solution and address of scavenger",
		Args:  cobra.ExactArgs(2),
		RunE: func(cmd *cobra.Command, args []string) error {
			cliCtx := context.NewCLIContext().WithCodec(cdc)

			var solution = args[0]
			var solutionHash = sha256.Sum256([]byte(solution))
			var solutionHashString = hex.EncodeToString(solutionHash[:])

			var scavenger = args[1]

			var solutionScavengerHash = sha256.Sum256([]byte(solution + scavenger))
			var solutionScavengerHashString = hex.EncodeToString(solutionScavengerHash[:])

			res, _, err := cliCtx.QueryWithData(fmt.Sprintf("custom/%s/%s/%s", queryRoute, types.QueryCommit, solutionScavengerHashString), nil)
			if err != nil {
				fmt.Printf("could not resolve commit %s for scavenge %s \n%s\n", solutionScavengerHashString, solutionHashString, err.Error())
				return nil
			}

			var out types.Commit
			cdc.MustUnmarshalJSON(res, &out)
			return cliCtx.PrintOutput(out)
		},
	}
}
```

注意，这个文件还利用了`sha256`库将纯文本转换成十六进制散列字符串。

虽然这些都是一个模块的主要移动部分(`Message`、`Handler`、`Keeper`、`Querier`和`Client`)，但还有一些组织任务我们尚未完成。下一步将是确保我们的模块被完全配置，以使它可以在任何应用程序中使用。

# 组件

我们的`scaffold`工具已经为我们完成了在`./x/scavenge/`中生成`module.go`文件的大部分工作。我们的模块不同于最简单形式的模块的一个方面是，它使用自己的`Keeper`以及来自`bank`模块的`Keeper`。唯一真正需要更改的是在`AppModule`和`NewAppModule`下，这里需要添加和引用`bank.Keeper`。之后，该文件应该如下所示:

```js
package scavenge

import (
	"encoding/json"

	"github.com/gorilla/mux"
	"github.com/spf13/cobra"

	abci "github.com/tendermint/tendermint/abci/types"

	"github.com/cosmos/cosmos-sdk/client/context"
	"github.com/cosmos/cosmos-sdk/codec"
	sdk "github.com/cosmos/cosmos-sdk/types"
	"github.com/cosmos/cosmos-sdk/types/module"
	"github.com/cosmos/cosmos-sdk/x/bank"
	"github.com/cosmos/sdk-tutorials/scavenge/x/scavenge/client/cli"
	"github.com/cosmos/sdk-tutorials/scavenge/x/scavenge/client/rest"
	"github.com/cosmos/sdk-tutorials/scavenge/x/scavenge/types"
)

var (
	_ module.AppModule      = AppModule{}
	_ module.AppModuleBasic = AppModuleBasic{}
)

// AppModuleBasic defines the basic application module used by the scavenge module.
type AppModuleBasic struct{}

var _ module.AppModuleBasic = AppModuleBasic{}

// Name returns the scavenge module's name.
func (AppModuleBasic) Name() string {
	return types.ModuleName
}

// RegisterCodec registers the scavenge module's types for the given codec.
func (AppModuleBasic) RegisterCodec(cdc *codec.Codec) {
	RegisterCodec(cdc)
}

// DefaultGenesis returns default genesis state as raw bytes for the scavenge
// module.
func (AppModuleBasic) DefaultGenesis() json.RawMessage {
	return ModuleCdc.MustMarshalJSON(DefaultGenesisState())
}

// ValidateGenesis performs genesis state validation for the scavenge module.
func (AppModuleBasic) ValidateGenesis(bz json.RawMessage) error {
	var data GenesisState
	err := ModuleCdc.UnmarshalJSON(bz, &data)
	if err != nil {
		return err
	}
	return ValidateGenesis(data)
}

// RegisterRESTRoutes registers the REST routes for the scavenge module.
func (AppModuleBasic) RegisterRESTRoutes(ctx context.CLIContext, rtr *mux.Router) {
	rest.RegisterRoutes(ctx, rtr)
}

// GetTxCmd returns the root tx command for the scavenge module.
func (AppModuleBasic) GetTxCmd(cdc *codec.Codec) *cobra.Command {
	return cli.GetTxCmd(cdc)
}

// GetQueryCmd returns no root query command for the scavenge module.
func (AppModuleBasic) GetQueryCmd(cdc *codec.Codec) *cobra.Command {
	return cli.GetQueryCmd(StoreKey, cdc)
}

//____________________________________________________________________________

// AppModule implements an application module for the scavenge module.
type AppModule struct {
	AppModuleBasic
	keeper     Keeper
	coinKeeper bank.Keeper
}

// NewAppModule creates a new AppModule object
func NewAppModule(k Keeper, bankKeeper bank.Keeper) AppModule {
	return AppModule{
		AppModuleBasic: AppModuleBasic{},
		keeper:         k,
		coinKeeper:     bankKeeper,
	}
}

// Name returns the scavenge module's name.
func (AppModule) Name() string {
	return ModuleName
}

// RegisterInvariants registers the scavenge module invariants.
func (am AppModule) RegisterInvariants(_ sdk.InvariantRegistry) {}

// Route returns the message routing key for the scavenge module.
func (AppModule) Route() string {
	return RouterKey
}

// NewHandler returns an sdk.Handler for the scavenge module.
func (am AppModule) NewHandler() sdk.Handler {
	return NewHandler(am.keeper)
}

// QuerierRoute returns the scavenge module's querier route name.
func (AppModule) QuerierRoute() string {
	return QuerierRoute
}

// NewQuerierHandler returns the scavenge module sdk.Querier.
func (am AppModule) NewQuerierHandler() sdk.Querier {
	return NewQuerier(am.keeper)
}

// InitGenesis performs genesis initialization for the scavenge module. It returns
// no validator updates.
func (am AppModule) InitGenesis(ctx sdk.Context, data json.RawMessage) []abci.ValidatorUpdate {
	var genesisState GenesisState
	ModuleCdc.MustUnmarshalJSON(data, &genesisState)
	InitGenesis(ctx, am.keeper, genesisState)
	return []abci.ValidatorUpdate{}
}

// ExportGenesis returns the exported genesis state as raw bytes for the scavenge
// module.
func (am AppModule) ExportGenesis(ctx sdk.Context) json.RawMessage {
	gs := ExportGenesis(ctx, am.keeper)
	return ModuleCdc.MustMarshalJSON(gs)
}

// BeginBlock returns the begin blocker for the scavenge module.
func (am AppModule) BeginBlock(ctx sdk.Context, req abci.RequestBeginBlock) {
	BeginBlocker(ctx, req, am.keeper)
}

// EndBlock returns the end blocker for the scavenge module. It returns no validator
// updates.
func (AppModule) EndBlock(sdk.Context, abci.RequestEndBlock) []abci.ValidatorUpdate {
	return nil
}
```

恭喜您完成了`scavenge`模块！

这个模块现在可以集成到任何 Cosmos SDK 应用程序中。

因为我们不想*只是*构建一个模块，而是想构建一个也使用该模块的应用程序，所以让我们来完成配置应用程序的过程。

# 应用

我们的`scaffold`实用程序已经在`./app/app.go`中为我们创建了一个相当完整的`app.go`文件。这个版本的`app.go`文件意味着尽可能简单的应用程序。它只包含使用应用程序所需的必要模块，这些应用程序知道硬币(`bank`)、用户帐户(`auth`)以及用利害关系证明保护应用程序(`staking`)。

有一个模块是缺失的，但却是 Cosmos SDK 核心特性集的一部分，那就是`gov`，它允许进行简单形式的治理。这一过程包括提出文本提案，可以用硬币或通过[液体民主](https://en.wikipedia.org/wiki/Liquid_democracy)委托投票表决。该模块还可用于通过参数更改来更新应用程序本身的逻辑，这些参数更改会影响不同模块的特定部分。

大多数情况下，我们可以按照文件中标记的`TODO`添加关于新模块的必要信息。之后，它应该看起来像:

```js
package app

import (
	"encoding/json"
	"io"
	"os"

	abci "github.com/tendermint/tendermint/abci/types"
	"github.com/tendermint/tendermint/libs/log"
	tmos "github.com/tendermint/tendermint/libs/os"
	dbm "github.com/tendermint/tm-db"

	bam "github.com/cosmos/cosmos-sdk/baseapp"
	"github.com/cosmos/cosmos-sdk/codec"
	"github.com/cosmos/cosmos-sdk/simapp"
	sdk "github.com/cosmos/cosmos-sdk/types"
	"github.com/cosmos/cosmos-sdk/types/module"
	"github.com/cosmos/cosmos-sdk/version"
	"github.com/cosmos/cosmos-sdk/x/auth"
	"github.com/cosmos/cosmos-sdk/x/auth/vesting"
	"github.com/cosmos/cosmos-sdk/x/bank"
	distr "github.com/cosmos/cosmos-sdk/x/distribution"
	"github.com/cosmos/cosmos-sdk/x/genutil"
	"github.com/cosmos/cosmos-sdk/x/params"
	"github.com/cosmos/cosmos-sdk/x/slashing"
	"github.com/cosmos/cosmos-sdk/x/staking"
	"github.com/cosmos/cosmos-sdk/x/supply"
	"github.com/cosmos/sdk-tutorials/scavenge/x/scavenge"
)

const appName = "app"

var (
	// default home directories for the application CLI
	DefaultCLIHome = os.ExpandEnv("$HOME/.scavengeCLI")

	// DefaultNodeHome sets the folder where the applcation data and configuration will be stored
	DefaultNodeHome = os.ExpandEnv("$HOME/.scavengeD")

	// NewBasicManager is in charge of setting up basic module elemnets
	ModuleBasics = module.NewBasicManager(
		genutil.AppModuleBasic{},
		auth.AppModuleBasic{},
		bank.AppModuleBasic{},
		staking.AppModuleBasic{},
		distr.AppModuleBasic{},
		params.AppModuleBasic{},
		slashing.AppModuleBasic{},
		supply.AppModuleBasic{},

		scavenge.AppModuleBasic{},
	)
	// account permissions
	maccPerms = map[string][]string{
		auth.FeeCollectorName:     nil,
		distr.ModuleName:          nil,
		staking.BondedPoolName:    {supply.Burner, supply.Staking},
		staking.NotBondedPoolName: {supply.Burner, supply.Staking},
	}
)

// MakeCodec generates the necessary codecs for Amino
func MakeCodec() *codec.Codec {
	var cdc = codec.New()

	ModuleBasics.RegisterCodec(cdc)
	vesting.RegisterCodec(cdc)
	sdk.RegisterCodec(cdc)
	codec.RegisterCrypto(cdc)

	return cdc.Seal()
}

type NewApp struct {
	*bam.BaseApp
	cdc *codec.Codec

	// keys to access the substores
	keys  map[string]*sdk.KVStoreKey
	tkeys map[string]*sdk.TransientStoreKey

	// subspaces
	subspaces map[string]params.Subspace

	// Keepers
	accountKeeper  auth.AccountKeeper
	bankKeeper     bank.Keeper
	stakingKeeper  staking.Keeper
	slashingKeeper slashing.Keeper
	distrKeeper    distr.Keeper
	supplyKeeper   supply.Keeper
	paramsKeeper   params.Keeper
	scavengeKeeper scavenge.Keeper

	// Module Manager
	mm *module.Manager

	// simulation manager
	sm *module.SimulationManager
}

// verify app interface at compile time
var _ simapp.App = (*NewApp)(nil)

// NewInitApp is a constructor function for scavengeApp
func NewInitApp(logger log.Logger, db dbm.DB, traceStore io.Writer, loadLatest bool,
	invCheckPeriod uint, baseAppOptions ...func(*bam.BaseApp)) *NewApp {

	// First define the top level codec that will be shared by the different modules
	cdc := MakeCodec()

	// BaseApp handles interactions with Tendermint through the ABCI protocol
	bApp := bam.NewBaseApp(appName, logger, db, auth.DefaultTxDecoder(cdc), baseAppOptions...)

	bApp.SetAppVersion(version.Version)

	keys := sdk.NewKVStoreKeys(bam.MainStoreKey, auth.StoreKey, staking.StoreKey,
		supply.StoreKey, distr.StoreKey, slashing.StoreKey, params.StoreKey, scavenge.StoreKey)

	tkeys := sdk.NewTransientStoreKeys(staking.TStoreKey, params.TStoreKey)

	// Here you initialize your application with the store keys it requires
	var app = &NewApp{
		BaseApp:   bApp,
		cdc:       cdc,
		keys:      keys,
		tkeys:     tkeys,
		subspaces: make(map[string]params.Subspace),
	}

	// The ParamsKeeper handles parameter storage for the application
	app.paramsKeeper = params.NewKeeper(app.cdc, keys[params.StoreKey], tkeys[params.TStoreKey])
	// Set specific supspaces
	app.subspaces[auth.ModuleName] = app.paramsKeeper.Subspace(auth.DefaultParamspace)
	app.subspaces[bank.ModuleName] = app.paramsKeeper.Subspace(bank.DefaultParamspace)
	app.subspaces[staking.ModuleName] = app.paramsKeeper.Subspace(staking.DefaultParamspace)
	app.subspaces[distr.ModuleName] = app.paramsKeeper.Subspace(distr.DefaultParamspace)
	app.subspaces[slashing.ModuleName] = app.paramsKeeper.Subspace(slashing.DefaultParamspace)

	// The AccountKeeper handles address -> account lookups
	app.accountKeeper = auth.NewAccountKeeper(
		app.cdc,
		keys[auth.StoreKey],
		app.subspaces[auth.ModuleName],
		auth.ProtoBaseAccount,
	)

	// The BankKeeper allows you perform sdk.Coins interactions
	app.bankKeeper = bank.NewBaseKeeper(
		app.accountKeeper,
		app.subspaces[bank.ModuleName],
		app.ModuleAccountAddrs(),
	)

	// The SupplyKeeper collects transaction fees and renders them to the fee distribution module
	app.supplyKeeper = supply.NewKeeper(
		app.cdc,
		keys[supply.StoreKey],
		app.accountKeeper,
		app.bankKeeper,
		maccPerms,
	)

	// The staking keeper
	stakingKeeper := staking.NewKeeper(
		app.cdc,
		keys[staking.StoreKey],
		app.supplyKeeper,
		app.subspaces[staking.ModuleName],
	)

	app.distrKeeper = distr.NewKeeper(
		app.cdc,
		keys[distr.StoreKey],
		app.subspaces[distr.ModuleName],
		&stakingKeeper,
		app.supplyKeeper,
		auth.FeeCollectorName,
		app.ModuleAccountAddrs(),
	)

	app.slashingKeeper = slashing.NewKeeper(
		app.cdc,
		keys[slashing.StoreKey],
		&stakingKeeper,
		app.subspaces[slashing.ModuleName],
	)

	// register the staking hooks
	// NOTE: stakingKeeper above is passed by reference, so that it will contain these hooks
	app.stakingKeeper = *stakingKeeper.SetHooks(
		staking.NewMultiStakingHooks(
			app.distrKeeper.Hooks(),
			app.slashingKeeper.Hooks()),
	)

	app.scavengeKeeper = scavenge.NewKeeper(
		app.bankKeeper,
		app.cdc,
		keys[scavenge.StoreKey],
	)

	app.mm = module.NewManager(
		genutil.NewAppModule(app.accountKeeper, app.stakingKeeper, app.BaseApp.DeliverTx),
		auth.NewAppModule(app.accountKeeper),
		bank.NewAppModule(app.bankKeeper, app.accountKeeper),
		scavenge.NewAppModule(app.scavengeKeeper, app.bankKeeper),
		supply.NewAppModule(app.supplyKeeper, app.accountKeeper),
		distr.NewAppModule(app.distrKeeper, app.accountKeeper, app.supplyKeeper, app.stakingKeeper),
		slashing.NewAppModule(app.slashingKeeper, app.accountKeeper, app.stakingKeeper),
		staking.NewAppModule(app.stakingKeeper, app.accountKeeper, app.supplyKeeper),
	)

	app.mm.SetOrderBeginBlockers(distr.ModuleName, slashing.ModuleName)
	app.mm.SetOrderEndBlockers(staking.ModuleName)

	// Sets the order of Genesis - Order matters, genutil is to always come last
	// NOTE: The genutils moodule must occur after staking so that pools are
	// properly initialized with tokens from genesis accounts.
	app.mm.SetOrderInitGenesis(
		distr.ModuleName,
		staking.ModuleName,
		auth.ModuleName,
		bank.ModuleName,
		slashing.ModuleName,
		scavenge.ModuleName,
		supply.ModuleName,
		genutil.ModuleName,
	)

	// register all module routes and module queriers
	app.mm.RegisterRoutes(app.Router(), app.QueryRouter())

	// The initChainer handles translating the genesis.json file into initial state for the network
	app.SetInitChainer(app.InitChainer)
	app.SetBeginBlocker(app.BeginBlocker)
	app.SetEndBlocker(app.EndBlocker)

	// The AnteHandler handles signature verification and transaction pre-processing
	app.SetAnteHandler(
		auth.NewAnteHandler(
			app.accountKeeper,
			app.supplyKeeper,
			auth.DefaultSigVerificationGasConsumer,
		),
	)

	// initialize stores
	app.MountKVStores(keys)
	app.MountTransientStores(tkeys)

	err := app.LoadLatestVersion(app.keys[bam.MainStoreKey])
	if err != nil {
		tmos.Exit(err.Error())
	}

	return app
}

// GenesisState represents chain state at the start of the chain. Any initial state (account balances) are stored here.
type GenesisState map[string]json.RawMessage

func NewDefaultGenesisState() GenesisState {
	return ModuleBasics.DefaultGenesis()
}

func (app *NewApp) InitChainer(ctx sdk.Context, req abci.RequestInitChain) abci.ResponseInitChain {
	var genesisState GenesisState

	err := app.cdc.UnmarshalJSON(req.AppStateBytes, &genesisState)
	if err != nil {
		panic(err)
	}

	return app.mm.InitGenesis(ctx, genesisState)
}

func (app *NewApp) BeginBlocker(ctx sdk.Context, req abci.RequestBeginBlock) abci.ResponseBeginBlock {
	return app.mm.BeginBlock(ctx, req)
}

func (app *NewApp) EndBlocker(ctx sdk.Context, req abci.RequestEndBlock) abci.ResponseEndBlock {
	return app.mm.EndBlock(ctx, req)
}

func (app *NewApp) LoadHeight(height int64) error {
	return app.LoadVersion(height, app.keys[bam.MainStoreKey])
}

// Codec returns simapp's codec
func (app *NewApp) Codec() *codec.Codec {
	return app.cdc
}

// SimulationManager implements the SimulationApp interface
func (app *NewApp) SimulationManager() *module.SimulationManager {
	return app.sm
}

// ModuleAccountAddrs returns all the app's module account addresses.
func (app *NewApp) ModuleAccountAddrs() map[string]bool {
	modAccAddrs := make(map[string]bool)
	for acc := range maccPerms {
		modAccAddrs[supply.NewModuleAddress(acc).String()] = true
	}

	return modAccAddrs
}
```

您可能会注意到，在文件开头附近，我重命名了`DefaultCLIHome`和`DefaultNodeHome`。这些目录位于您的计算机上，其中存储了您的应用程序的历史记录和 CLI 的配置，以及您在计算机上生成的密钥的加密信息。我将它们重命名为`scavengeCLI`和`scavengeD`，以更好地反映我们的应用程序。

由于我们不想使用由`scaffold`命令提供给我们的 CLI 和应用程序的通用命令，让我们也重命名`cmd`中的文件。我们将把`./cmd/appcli/`改名为`./cmd/scavengeCLI`，把`./cmd/appd`改名为`./cmd/scavengeD`。在我们的`./cmd/scavengeCLI/main.go`文件中，我们也将更新为以下格式:

```js
package main

import (
	"fmt"
	"os"
	"path"

	"github.com/cosmos/cosmos-sdk/client"
	"github.com/cosmos/cosmos-sdk/client/flags"
	"github.com/cosmos/cosmos-sdk/client/keys"
	"github.com/cosmos/cosmos-sdk/client/lcd"
	"github.com/cosmos/cosmos-sdk/client/rpc"
	sdk "github.com/cosmos/cosmos-sdk/types"
	"github.com/cosmos/cosmos-sdk/version"
	"github.com/cosmos/cosmos-sdk/x/auth"
	authcmd "github.com/cosmos/cosmos-sdk/x/auth/client/cli"
	"github.com/cosmos/cosmos-sdk/x/bank"
	bankcmd "github.com/cosmos/cosmos-sdk/x/bank/client/cli"
	"github.com/cosmos/sdk-tutorials/scavenge/app"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	amino "github.com/tendermint/go-amino"
	"github.com/tendermint/tendermint/libs/cli"
)

func main() {
	// Configure cobra to sort commands
	cobra.EnableCommandSorting = false

	// Instantiate the codec for the command line application
	cdc := app.MakeCodec()

	// Read in the configuration file for the sdk
	config := sdk.GetConfig()
	config.SetBech32PrefixForAccount(sdk.Bech32PrefixAccAddr, sdk.Bech32PrefixAccPub)
	config.SetBech32PrefixForValidator(sdk.Bech32PrefixValAddr, sdk.Bech32PrefixValPub)
	config.SetBech32PrefixForConsensusNode(sdk.Bech32PrefixConsAddr, sdk.Bech32PrefixConsPub)
	config.Seal()

	rootCmd := &cobra.Command{
		Use:   "scavengeCLI",
		Short: "Scavenge Client",
	}

	// Add --chain-id to persistent flags and mark it required
	rootCmd.PersistentFlags().String(flags.FlagChainID, "", "Chain ID of tendermint node")
	rootCmd.PersistentPreRunE = func(_ *cobra.Command, _ []string) error {
		return initConfig(rootCmd)
	}

	// Construct Root Command
	rootCmd.AddCommand(
		rpc.StatusCommand(),
		client.ConfigCmd(app.DefaultCLIHome),
		queryCmd(cdc),
		txCmd(cdc),
		flags.LineBreak,
		lcd.ServeCommand(cdc, registerRoutes),
		flags.LineBreak,
		keys.Commands(),
		flags.LineBreak,
		version.Cmd,
		flags.NewCompletionCmd(rootCmd, true),
	)

	// Add flags and prefix all env exposed with AA
	executor := cli.PrepareMainCmd(rootCmd, "AA", app.DefaultCLIHome)

	err := executor.Execute()
	if err != nil {
		fmt.Printf("Failed executing CLI command: %s, exiting...\n", err)
		os.Exit(1)
	}
}

func queryCmd(cdc *amino.Codec) *cobra.Command {
	queryCmd := &cobra.Command{
		Use:     "query",
		Aliases: []string{"q"},
		Short:   "Querying subcommands",
	}

	queryCmd.AddCommand(
		authcmd.GetAccountCmd(cdc),
		flags.LineBreak,
		rpc.ValidatorCommand(cdc),
		rpc.BlockCommand(),
		authcmd.QueryTxsByEventsCmd(cdc),
		authcmd.QueryTxCmd(cdc),
		flags.LineBreak,
	)

	// add modules' query commands
	app.ModuleBasics.AddQueryCommands(queryCmd, cdc)

	return queryCmd
}

func txCmd(cdc *amino.Codec) *cobra.Command {
	txCmd := &cobra.Command{
		Use:   "tx",
		Short: "Transactions subcommands",
	}

	txCmd.AddCommand(
		bankcmd.SendTxCmd(cdc),
		flags.LineBreak,
		authcmd.GetSignCommand(cdc),
		authcmd.GetMultiSignCommand(cdc),
		flags.LineBreak,
		authcmd.GetBroadcastCommand(cdc),
		authcmd.GetEncodeCommand(cdc),
		authcmd.GetDecodeCommand(cdc),
		flags.LineBreak,
	)

	// add modules' tx commands
	app.ModuleBasics.AddTxCommands(txCmd, cdc)

	// remove auth and bank commands as they're mounted under the root tx command
	var cmdsToRemove []*cobra.Command

	for _, cmd := range txCmd.Commands() {
		if cmd.Use == auth.ModuleName || cmd.Use == bank.ModuleName {
			cmdsToRemove = append(cmdsToRemove, cmd)
		}
	}

	txCmd.RemoveCommand(cmdsToRemove...)

	return txCmd
}

func registerRoutes(rs *lcd.RestServer) {
	client.RegisterRoutes(rs.CliCtx, rs.Mux)
	app.ModuleBasics.RegisterRESTRoutes(rs.CliCtx, rs.Mux)
}

func initConfig(cmd *cobra.Command) error {
	home, err := cmd.PersistentFlags().GetString(cli.HomeFlag)
	if err != nil {
		return err
	}

	cfgFile := path.Join(home, "config", "config.toml")
	if _, err := os.Stat(cfgFile); err == nil {
		viper.SetConfigFile(cfgFile)

		if err := viper.ReadInConfig(); err != nil {
			return err
		}
	}
	if err := viper.BindPFlag(flags.FlagChainID, cmd.PersistentFlags().Lookup(flags.FlagChainID)); err != nil {
		return err
	}
	if err := viper.BindPFlag(cli.EncodingFlag, cmd.PersistentFlags().Lookup(cli.EncodingFlag)); err != nil {
		return err
	}
	return viper.BindPFlag(cli.OutputFlag, cmd.PersistentFlags().Lookup(cli.OutputFlag))
}
```

在我们的`./cmd/scavengeD/main.go`中，我们将更新为以下格式:

```js
package main

import (
	"encoding/json"
	"io"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"

	abci "github.com/tendermint/tendermint/abci/types"
	"github.com/tendermint/tendermint/libs/cli"
	"github.com/tendermint/tendermint/libs/log"
	tmtypes "github.com/tendermint/tendermint/types"
	dbm "github.com/tendermint/tm-db"

	"github.com/cosmos/cosmos-sdk/baseapp"
	"github.com/cosmos/cosmos-sdk/client/debug"
	"github.com/cosmos/cosmos-sdk/client/flags"
	"github.com/cosmos/cosmos-sdk/server"
	"github.com/cosmos/cosmos-sdk/store"
	storetypes "github.com/cosmos/cosmos-sdk/store/types"
	sdk "github.com/cosmos/cosmos-sdk/types"
	"github.com/cosmos/cosmos-sdk/x/auth"
	genutilcli "github.com/cosmos/cosmos-sdk/x/genutil/client/cli"
	"github.com/cosmos/cosmos-sdk/x/staking"

	app "github.com/cosmos/sdk-tutorials/scavenge/app"
)

const flagInvCheckPeriod = "inv-check-period"

var invCheckPeriod uint

func main() {
	cdc := app.MakeCodec()

	config := sdk.GetConfig()
	config.SetBech32PrefixForAccount(sdk.Bech32PrefixAccAddr, sdk.Bech32PrefixAccPub)
	config.SetBech32PrefixForValidator(sdk.Bech32PrefixValAddr, sdk.Bech32PrefixValPub)
	config.SetBech32PrefixForConsensusNode(sdk.Bech32PrefixConsAddr, sdk.Bech32PrefixConsPub)
	config.Seal()

	ctx := server.NewDefaultContext()
	cobra.EnableCommandSorting = false
	rootCmd := &cobra.Command{
		Use:               "scavengeD",
		Short:             "Scavenge Daemon (server)",
		PersistentPreRunE: server.PersistentPreRunEFn(ctx),
	}

	rootCmd.AddCommand(genutilcli.InitCmd(ctx, cdc, app.ModuleBasics, app.DefaultNodeHome))
	rootCmd.AddCommand(genutilcli.CollectGenTxsCmd(ctx, cdc, auth.GenesisAccountIterator{}, app.DefaultNodeHome))
	rootCmd.AddCommand(genutilcli.MigrateGenesisCmd(ctx, cdc))
	rootCmd.AddCommand(
		genutilcli.GenTxCmd(
			ctx, cdc, app.ModuleBasics, staking.AppModuleBasic{},
			auth.GenesisAccountIterator{}, app.DefaultNodeHome, app.DefaultCLIHome,
		),
	)
	rootCmd.AddCommand(genutilcli.ValidateGenesisCmd(ctx, cdc, app.ModuleBasics))
	rootCmd.AddCommand(AddGenesisAccountCmd(ctx, cdc, app.DefaultNodeHome, app.DefaultCLIHome))
	rootCmd.AddCommand(flags.NewCompletionCmd(rootCmd, true))
	rootCmd.AddCommand(debug.Cmd(cdc))

	server.AddCommands(ctx, cdc, rootCmd, newApp, exportAppStateAndTMValidators)

	// prepare and add flags
	executor := cli.PrepareBaseCmd(rootCmd, "AU", app.DefaultNodeHome)
	rootCmd.PersistentFlags().UintVar(&invCheckPeriod, flagInvCheckPeriod,
		0, "Assert registered invariants every N blocks")
	err := executor.Execute()
	if err != nil {
		panic(err)
	}
}

func newApp(logger log.Logger, db dbm.DB, traceStore io.Writer) abci.Application {
	var cache sdk.MultiStorePersistentCache

	if viper.GetBool(server.FlagInterBlockCache) {
		cache = store.NewCommitKVStoreCacheManager()
	}

	return app.NewInitApp(
		logger, db, traceStore, true, invCheckPeriod,
		baseapp.SetPruning(storetypes.NewPruningOptionsFromString(viper.GetString("pruning"))),
		baseapp.SetMinGasPrices(viper.GetString(server.FlagMinGasPrices)),
		baseapp.SetHaltHeight(viper.GetUint64(server.FlagHaltHeight)),
		baseapp.SetHaltTime(viper.GetUint64(server.FlagHaltTime)),
		baseapp.SetInterBlockCache(cache),
	)
}

func exportAppStateAndTMValidators(
	logger log.Logger, db dbm.DB, traceStore io.Writer, height int64, forZeroHeight bool, jailWhiteList []string,
) (json.RawMessage, []tmtypes.GenesisValidator, error) {

	if height != -1 {
		aApp := app.NewInitApp(logger, db, traceStore, false, uint(1))
		err := aApp.LoadHeight(height)
		if err != nil {
			return nil, nil, err
		}
		return aApp.ExportAppStateAndValidators(forZeroHeight, jailWhiteList)
	}

	aApp := app.NewInitApp(logger, db, traceStore, true, uint(1))

	return aApp.ExportAppStateAndValidators(forZeroHeight, jailWhiteList)
}
```

最后，我们需要在我们的`Makefile`中更新新的`cmd`名称。它应该更新为如下所示:

```js
PACKAGES=$(shell go list ./... | grep -v '/simulation')

VERSION := $(shell echo $(shell git describe --tags) | sed 's/^v//')
COMMIT := $(shell git log -1 --format='%H')

ldflags = -X github.com/cosmos/cosmos-sdk/version.Name=NewApp \
	-X github.com/cosmos/cosmos-sdk/version.ServerName=scavengeD \
	-X github.com/cosmos/cosmos-sdk/version.ClientName=scavengeCLI \
	-X github.com/cosmos/cosmos-sdk/version.Version=$(VERSION) \
	-X github.com/cosmos/cosmos-sdk/version.Commit=$(COMMIT) 

BUILD_FLAGS := -ldflags '$(ldflags)'

.PHONY: all
all: install

.PHONY: install
install: go.sum
		go install -mod=readonly $(BUILD_FLAGS) ./cmd/scavengeD
		go install -mod=readonly $(BUILD_FLAGS) ./cmd/scavengeCLI

go.sum: go.mod
		@echo "--> Ensure dependencies have not been modified"
		GO111MODULE=on go mod verify

# Uncomment when you have some tests
# test:
# 	@go test -mod=readonly $(PACKAGES)
.PHONY: lint
# look into .golangci.yml for enabling / disabling linters
lint:
	@echo "--> Running linter"
	@golangci-lint run
	@go mod verify
```

现在我们的应用程序已经配置好了，可以开始运行了！

让我们开始吧🔥

# 运行应用程序

现在我们的模块已经构建好了，我们的应用程序也配置好了，我们可以开始运行我们的应用程序了！首先要做的是确保`go.mod`是正确的。如果您使用的是启用了`golang`扩展的 IDE，比如 vscode，那么在保存每个文件后，这应该会自动完成。您还可以通过运行`go mod tidy`来确保所有的依赖项都存在。

一旦设置了依赖项，运行`make`来构建二进制文件！您将创建两个二进制文件。一个是`scavengeD`，它是运行实际应用程序的守护进程。另一个二进制文件是`scavengeCLI`，它是一个与你正在运行的应用程序交互的工具。

在运行了`make`之后，您希望确保您可以访问这两个二进制文件。您可以通过运行`scavengeD --help`来做到这一点，您应该会看到以下内容:

```js
Scavenge Daemon (server)

Usage:
  scavengeD [command]

Available Commands:
  init                Initialize private validator, p2p, genesis, and application configuration files
  collect-gentxs      Collect genesis txs and output a genesis.json file
  gentx               Generate a genesis tx carrying a self delegation
  validate-genesis    validates the genesis file at the default location or at the location passed as an arg
  add-genesis-account Add genesis account to genesis.json
  start               Run the full node
  unsafe-reset-all    Resets the blockchain database, removes address book files, and resets priv_validator.json to the genesis state

  tendermint          Tendermint subcommands
  export              Export state to JSON

  version             Print the app version
  help                Help about any command

Flags:
  -h, --help                    help for scavengeD
      --home string             directory for config and data (default "/home/billy/.scavengeD")
      --inv-check-period uint   Assert registered invariants every N blocks
      --log_level string        Log level (default "main:info,state:info,*:error")
      --trace                   print out full stack trace on errors

Use "scavengeD [command] --help" for more information about a command. 
```

您还应该能够运行`scavengeCLI --help`,这将产生以下屏幕:

```js
Scavenge Client

Usage:
  scavengeCLI [command]

Available Commands:
  status      Query remote node for status
  config      Create or query an application CLI configuration file
  query       Querying subcommands
  tx          Transactions subcommands

  rest-server Start LCD (light-client daemon), a local REST server

  keys        Add or view local private keys

  version     Print the app version
  help        Help about any command

Flags:
      --chain-id string   Chain ID of tendermint node
  -e, --encoding string   Binary encoding (hex|b64|btc) (default "hex")
  -h, --help              help for scavengeCLI
      --home string       directory for config and data (default "/home/billy/.scavengeCLI")
  -o, --output string     Output format (text|json) (default "text")
      --trace             print out full stack trace on errors

Use "scavengeCLI [command] --help" for more information about a command. 
```

现在，我们应该在我们的应用程序中创建一些用户，这些用户拥有一些初始硬币，可以用作其他玩家的奖金。首先，我们使用以下命令创建两个用户:

```js
scavengeCLI keys add me
scavengeCLI keys add you 
```

每个命令都会提示设置密码来保护帐户。我通常在开发的时候使用`1234567890`，这样我就不会忘记。

接下来，您需要使用带有一个`<moniker>`(这只是您的机器的昵称)和一个`<chain-id>`的 Daemon 命令来初始化您的应用程序，这将是一种标识您的应用程序的方式。

```js
scavengeD init mynode --chain-id scavenge 
```

现在，您可以使用以下命令将您的两个帐户添加到应用程序的初始状态，称为 Genesis:

```js
scavengeD add-genesis-account $(scavengeCLI keys show me -a) 1000foo,100000000stake
scavengeD add-genesis-account $(scavengeCLI keys show you -a) 1foo 
```

注意，我们合并了两个命令，一个来自守护进程，一个来自 CLI。CLI 命令查询我们创建的帐户，但仅显示其地址。地址有点像用户 id。您还会注意到，我们为不同的用户添加了一些硬币。对于用户`me`，我们添加了一个名为`foo`的令牌和一个名为`stake`的令牌。我们将在利益证明验证流程中使用`stake`。由于用户`me`是唯一拥有`stake`的用户，他们将是唯一与该应用程序交互的**验证者**。这对我们的目的来说很好，因为我们只是在玩，但如果你要在生产中运行应用程序，你可能希望有更多的验证器来帮助确保你的应用程序正确运行。

在我们启动应用程序之前，最好将您的 CLI 配置为知道它将与此应用程序交互，而不是与任何其他应用程序交互。这些命令将告诉 CLI 只与此应用程序对话:

```js
scavengeCLI config chain-id scavenge
scavengeCLI config output json
scavengeCLI config indent true
scavengeCLI config trust-node true 
```

现在我们想让应用程序知道将由用户`me`进行验证，因此我们运行以下命令:

```js
scavengeD gentx --name me 
```

这个命令会要求输入密码，如果你和我一样，只需要输入`1234567890`。

我们的最后一步是告诉应用程序我们已经完成了配置。这将收集我们所有的初始配置，并准备应用程序开始:

```js
scavengeD collect-gentxs 
```

我通常将所有这些命令合并到一个可执行文件中，这样，如果我对应用程序进行更改，就不必手动运行每个命令。您可以在这里看到，我将配置设置为使用`keyring-backend`到`test`，这样我们就不需要每次都使用密码。我把所有东西都放在一个名为`./init.sh`的文件中，这样看起来就像这样:

```js
#!/bin/bash
rm -r ~/.scavengeCLI
rm -r ~/.scavengeD

scavengeD init mynode --chain-id scavenge

scavengeCLI config keyring-backend test

scavengeCLI keys add me
scavengeCLI keys add you

scavengeD add-genesis-account $(scavengeCLI keys show me -a) 1000foo,100000000stake
scavengeD add-genesis-account $(scavengeCLI keys show you -a) 1foo

scavengeCLI config chain-id scavenge
scavengeCLI config output json
scavengeCLI config indent true
scavengeCLI config trust-node true

scavengeD gentx --name me --keyring-backend test
scavengeD collect-gentxs
```

**现在，** ***最后*** **，你可以运行你的应用了！**

为此，请打开一个新的终端窗口，并键入以下内容:

```js
scavengeD start 
```

就是这样！你站起来了！

要使用您的应用程序，请看一下用于创建和解决清理器的示例命令。

## 玩

您的应用程序正在运行！那很好，但是谁在乎呢，除非你能玩它。您想要尝试的第一个命令是创建一个新的清除。因为我们的用户`me`比用户`you`拥有更多的`foo`令牌，所以让我们从他们的帐户创建一个清除。

您可以通过运行`scavengeCLI tx scavenge --help`来查看我们为您的新模块创建的所有命令。您应该看到以下选项:

```js
scavenge transactions subcommands

Usage:
  scavengeCLI tx scavenge [flags]
  scavengeCLI tx scavenge [command]

Available Commands:
  createScavenge Creates a new scavenge with a reward
  commitSolution Commits a solution for scavenge
  revealSolution Reveals a solution for scavenge

Flags:
  -h, --help   help for scavenge

Global Flags:
      --chain-id string   Chain ID of tendermint node
  -e, --encoding string   Binary encoding (hex|b64|btc) (default "hex")
      --home string       directory for config and data (default "/home/billy/.scavengeCLI")
  -o, --output string     Output format (text|json) (default "text")
      --trace             print out full stack trace on errors

Use "scavengeCLI tx scavenge [command] --help" for more information about a command.
```

我们想使用`createScavenge`命令，所以让我们像`scavengeCLI scavenge createScavenge --help`一样查看帮助屏幕。它应该看起来像:

```js
Creates a new scavenge with a reward

Usage:
  scavengeCLI tx scavenge createScavenge [reward] [solution] [description] [flags]

Flags:
  -a, --account-number uint     The account number of the signing account (offline mode only)
  -b, --broadcast-mode string   Transaction broadcasting mode (sync|async|block) (default "sync")
      --dry-run                 ignore the --gas flag and perform a simulation of a transaction, but don't broadcast it
      --fees string             Fees to pay along with transaction; eg: 10uatom
      --from string             Name or address of private key with which to sign
      --gas string              gas limit to set per-transaction; set to "auto" to calculate required gas automatically (default 200000) (default "200000")
      --gas-adjustment float    adjustment factor to be multiplied against the estimate returned by the tx simulation; if the gas limit is set manually this flag is ignored  (default 1)
      --gas-prices string       Gas prices to determine the transaction fee (e.g. 10uatom)
      --generate-only           Build an unsigned transaction and write it to STDOUT (when enabled, the local Keybase is not accessible and the node operates offline)
  -h, --help                    help for createScavenge
      --indent                  Add indent to JSON response
      --ledger                  Use a connected Ledger device
      --memo string             Memo to send along with transaction
      --node string             <host>:<port> to tendermint rpc interface for this chain (default "tcp://localhost:26657")
  -s, --sequence uint           The sequence number of the signing account (offline mode only)
      --trust-node              Trust connected full node (don't verify proofs for responses) (default true)
  -y, --yes                     Skip tx broadcasting prompt confirmation

Global Flags:
      --chain-id string   Chain ID of tendermint node
  -e, --encoding string   Binary encoding (hex|b64|btc) (default "hex")
      --home string       directory for config and data (default "/home/billy/.scavengeCLI")
  -o, --output string     Output format (text|json) (default "text") 
```

让我们按照说明创建一个新的清除。我们需要的第一个参数是`reward`。让我们送出`69foo`作为解决我们拾荒的奖励(nice)。

接下来，我们应该列出我们的`solution`，但也许我们还应该知道我们的解决方案解决的实际问题是什么(我们的`description`)。我们的挑战问题是家庭友好的怎么样:`What's brown and sticky?`。当然这个问题唯一的解决方法就是:`A stick`。

现在我们有了创建我们的信息所需的所有部分。让我们将它们组合在一起，添加标志`--from`,这样 CLI 就知道是谁在发送它:

```js
scavengeCLI tx scavenge createScavenge 69foo "A stick" "What's brown and sticky?" --from me 
```

在确认消息看起来正确并用您的密码(`1234567890`)签名后？)您应该会看到如下所示的内容:

```js
{
  "height": "0",
  "txhash": "3D088632B1C523EF2754153F5454E8FA464AE69747A4BD8ABC01A3428C31C185",
  "raw_log": "[{\"msg_index\":0,\"success\":true,\"log\":\"\",\"events\":[{\"type\":\"message\",\"attributes\":[{\"key\":\"action\",\"value\":\"CreateScavenge\"}]}]}]",
  "logs": [
    {
      "msg_index": 0,
      "success": true,
      "log": "",
      "events": [
        {
          "type": "message",
          "attributes": [
            {
              "key": "action",
              "value": "CreateScavenge"
            }
          ]
        }
      ]
    }
  ]
} 
```

这表明该消息已被应用程序接受。从该屏幕上无法判断消息后来是否失败。然而，`txhash`下的部分就像是这种互动的收据。要查看它在成功包含后是否被成功处理，您可以运行以下命令:

```js
scavengeCLI q tx <txhash> 
```

但是把`<txhash>`换成你自己的。之后，您应该会看到类似这样的内容:

```js
{
  "height": "2622",
  "txhash": "3D088632B1C523EF2754153F5454E8FA464AE69747A4BD8ABC01A3428C31C185",
  "raw_log": "[{\"msg_index\":0,\"success\":true,\"log\":\"\",\"events\":[{\"type\":\"message\",\"attributes\":[{\"key\":\"sender\",\"value\":\"cosmos1uajgdapslnsthwscpy474t3k69u0r8z3u0aaer\"},{\"key\":\"module\",\"value\":\"scavenge\"},{\"key\":\"action\",\"value\":\"CreateScavenge\"},{\"key\":\"sender\",\"value\":\"cosmos1uajgdapslnsthwscpy474t3k69u0r8z3u0aaer\"},{\"key\":\"description\",\"value\":\"What's brown and sticky?\"},{\"key\":\"solutionHash\",\"value\":\"2f9457a6e8fb202f9e10389a143a383106268c460743dd59d723c0f82d9ba906\"},{\"key\":\"reward\",\"value\":\"69foo\"},{\"key\":\"action\",\"value\":\"CreateScavenge\"}]},{\"type\":\"transfer\",\"attributes\":[{\"key\":\"recipient\",\"value\":\"cosmos13aupkh5020l9u6qquf7lvtcxhtr5jjama2kwyg\"},{\"key\":\"amount\",\"value\":\"69foo\"}]}]}]",
  "logs": [
    {
      "msg_index": 0,
      "success": true,
      "log": "",
      "events": [
        {
          "type": "message",
          "attributes": [
            {
              "key": "sender",
              "value": "cosmos1uajgdapslnsthwscpy474t3k69u0r8z3u0aaer"
            },
            {
              "key": "module",
              "value": "scavenge"
            },
            {
              "key": "action",
              "value": "CreateScavenge"
            },
            {
              "key": "sender",
              "value": "cosmos1uajgdapslnsthwscpy474t3k69u0r8z3u0aaer"
            },
            {
              "key": "description",
              "value": "What's brown and sticky?"
            },
            {
              "key": "solutionHash",
              "value": "2f9457a6e8fb202f9e10389a143a383106268c460743dd59d723c0f82d9ba906"
            },
            {
              "key": "reward",
              "value": "69foo"
            },
            {
              "key": "action",
              "value": "CreateScavenge"
            }
          ]
        },
        {
          "type": "transfer",
          "attributes": [
            {
              "key": "recipient",
              "value": "cosmos13aupkh5020l9u6qquf7lvtcxhtr5jjama2kwyg"
            },
            {
              "key": "amount",
              "value": "69foo"
            }
          ]
        }
      ]
    }
  ],
  "gas_wanted": "200000",
  "gas_used": "28218",
  "tx": {
    "type": "cosmos-sdk/StdTx",
    "value": {
      "msg": [
        {
          "type": "scavenge/CreateScavenge",
          "value": {
            "creator": "cosmos1uajgdapslnsthwscpy474t3k69u0r8z3u0aaer",
            "description": "What's brown and sticky?",
            "solutionHash": "2f9457a6e8fb202f9e10389a143a383106268c460743dd59d723c0f82d9ba906",
            "reward": [
              {
                "denom": "foo",
                "amount": "69"
              }
            ]
          }
        }
      ],
      "fee": {
        "amount": [],
        "gas": "200000"
      },
      "signatures": [
        {
          "pub_key": {
            "type": "tendermint/PubKeySecp256k1",
            "value": "Ag2Ukd9c1kczh/jpSNHAFZRkm2UfnVb+LHTqQ4SPGAVj"
          },
          "signature": "W222xWoImFlcspUhkb4BImM8WcTfmq8D3pQy83Ceo/109LWcBjRlsU+qrzOf2cC0rUz8EtakQJ5pcmU0+ZSUCQ=="
        }
      ],
      "memo": ""
    }
  },
  "timestamp": "2020-01-18T17:37:36Z",
  "events": [
    {
      "type": "message",
      "attributes": [
        {
          "key": "sender",
          "value": "cosmos1uajgdapslnsthwscpy474t3k69u0r8z3u0aaer"
        },
        {
          "key": "module",
          "value": "scavenge"
        },
        {
          "key": "action",
          "value": "CreateScavenge"
        },
        {
          "key": "sender",
          "value": "cosmos1uajgdapslnsthwscpy474t3k69u0r8z3u0aaer"
        },
        {
          "key": "description",
          "value": "What's brown and sticky?"
        },
        {
          "key": "solutionHash",
          "value": "2f9457a6e8fb202f9e10389a143a383106268c460743dd59d723c0f82d9ba906"
        },
        {
          "key": "reward",
          "value": "69foo"
        },
        {
          "key": "action",
          "value": "CreateScavenge"
        }
      ]
    },
    {
      "type": "transfer",
      "attributes": [
        {
          "key": "recipient",
          "value": "cosmos13aupkh5020l9u6qquf7lvtcxhtr5jjama2kwyg"
        },
        {
          "key": "amount",
          "value": "69foo"
        }
      ]
    }
  ]
} 
```

在这里，您可以看到我们在`Handler`中定义的所有事件，这些事件准确描述了处理该消息时发生的事情。由于我们的消息格式正确，并且用户`me`有足够的`foo`支付奖金，我们的`Scavenge`被接受。您还可以看到解决方案经过哈希处理后的样子:

```js
{
    "key": "solutionHash",
    "value": "2f9457a6e8fb202f9e10389a143a383106268c460743dd59d723c0f82d9ba906"
}
```

既然我们已经知道了这个问题的解决方案，而且我们手边还有另一个用户可以提交它，那么让我们开始提交和展示这个解决方案的过程。

首先，我们应该通过运行`scavengeCLI tx scavenge commitSolution --help`来检查针对`commitSolution`的 CLI 命令，以便查看:

```js
Commits a solution for scavenge

Usage:
  scavengeCLI tx scavenge commitSolution [solution] [flags]

Flags:
  -a, --account-number uint     The account number of the signing account (offline mode only)
  -b, --broadcast-mode string   Transaction broadcasting mode (sync|async|block) (default "sync")
      --dry-run                 ignore the --gas flag and perform a simulation of a transaction, but don't broadcast it
      --fees string             Fees to pay along with transaction; eg: 10uatom
      --from string             Name or address of private key with which to sign
      --gas string              gas limit to set per-transaction; set to "auto" to calculate required gas automatically (default 200000) (default "200000")
      --gas-adjustment float    adjustment factor to be multiplied against the estimate returned by the tx simulation; if the gas limit is set manually this flag is ignored  (default 1)
      --gas-prices string       Gas prices to determine the transaction fee (e.g. 10uatom)
      --generate-only           Build an unsigned transaction and write it to STDOUT (when enabled, the local Keybase is not accessible and the node operates offline)
  -h, --help                    help for commitSolution
      --indent                  Add indent to JSON response
      --ledger                  Use a connected Ledger device
      --memo string             Memo to send along with transaction
      --node string             <host>:<port> to tendermint rpc interface for this chain (default "tcp://localhost:26657")
  -s, --sequence uint           The sequence number of the signing account (offline mode only)
      --trust-node              Trust connected full node (don't verify proofs for responses) (default true)
  -y, --yes                     Skip tx broadcasting prompt confirmation

Global Flags:
      --chain-id string   Chain ID of tendermint node
  -e, --encoding string   Binary encoding (hex|b64|btc) (default "hex")
      --home string       directory for config and data (default "/home/billy/.scavengeCLI")
  -o, --output string     Output format (text|json) (default "text") 
```

让我们按照说明，代表`you`提交答案作为提交:

```js
scavengeCLI tx scavenge commitSolution "A stick" --from you 
```

我们不需要放入`solutionHash`,因为它可以通过散列我们的实际解来生成。确认交易并签字后，我们应该会再次看到我们的`txhash`。为了确认`txhash`，让我们用`scavengeCLI q tx <txhash>`再看一遍。这一次，您应该看到类似这样的内容:

```js
{
  "height": "2733",
  "txhash": "2E27A06BA7047FD41DC0DAD5481D99D5E58BC84DA0D7E0F4E1AC789F7A410186",
  "raw_log": "[{\"msg_index\":0,\"success\":true,\"log\":\"\",\"events\":[{\"type\":\"message\",\"attributes\":[{\"key\":\"module\",\"value\":\"scavenge\"},{\"key\":\"action\",\"value\":\"CommitSolution\"},{\"key\":\"sender\",\"value\":\"cosmos1m9pxr3nrra2cl07kh8hzdty5x0mejf44997f79\"},{\"key\":\"solutionHash\",\"value\":\"2f9457a6e8fb202f9e10389a143a383106268c460743dd59d723c0f82d9ba906\"},{\"key\":\"solutionScavengerHash\",\"value\":\"c65363ed8f6af5d5bd5d9fc9f955106fb7f3356cb218f939a5b658d8a46365a8\"},{\"key\":\"action\",\"value\":\"CommitSolution\"}]}]}]",
  "logs": [
    {
      "msg_index": 0,
      "success": true,
      "log": "",
      "events": [
        {
          "type": "message",
          "attributes": [
            {
              "key": "module",
              "value": "scavenge"
            },
            {
              "key": "action",
              "value": "CommitSolution"
            },
            {
              "key": "sender",
              "value": "cosmos1m9pxr3nrra2cl07kh8hzdty5x0mejf44997f79"
            },
            {
              "key": "solutionHash",
              "value": "2f9457a6e8fb202f9e10389a143a383106268c460743dd59d723c0f82d9ba906"
            },
            {
              "key": "solutionScavengerHash",
              "value": "c65363ed8f6af5d5bd5d9fc9f955106fb7f3356cb218f939a5b658d8a46365a8"
            },
            {
              "key": "action",
              "value": "CommitSolution"
            }
          ]
        }
      ]
    }
  ],
  "gas_wanted": "200000",
  "gas_used": "17130",
  "tx": {
    "type": "cosmos-sdk/StdTx",
    "value": {
      "msg": [
        {
          "type": "scavenge/CommitSolution",
          "value": {
            "scavenger": "cosmos1m9pxr3nrra2cl07kh8hzdty5x0mejf44997f79",
            "solutionhash": "2f9457a6e8fb202f9e10389a143a383106268c460743dd59d723c0f82d9ba906",
            "solutionScavengerHash": "c65363ed8f6af5d5bd5d9fc9f955106fb7f3356cb218f939a5b658d8a46365a8"
          }
        }
      ],
      "fee": {
        "amount": [],
        "gas": "200000"
      },
      "signatures": [
        {
          "pub_key": {
            "type": "tendermint/PubKeySecp256k1",
            "value": "AxHwDfJwPnyoTrt5o8L7iSCiUzIOsCOPovWicfgAyIZp"
          },
          "signature": "tUmtFxvNISe8SiUMRAYFkKuDJ58tcMQHfsAU0gZ55ZEcybAwvPou3ggTvVTIxicuI1bwjl7mTiLbplxJMQo6kA=="
        }
      ],
      "memo": ""
    }
  },
  "timestamp": "2020-01-18T17:46:54Z",
  "events": [
    {
      "type": "message",
      "attributes": [
        {
          "key": "module",
          "value": "scavenge"
        },
        {
          "key": "action",
          "value": "CommitSolution"
        },
        {
          "key": "sender",
          "value": "cosmos1m9pxr3nrra2cl07kh8hzdty5x0mejf44997f79"
        },
        {
          "key": "solutionHash",
          "value": "2f9457a6e8fb202f9e10389a143a383106268c460743dd59d723c0f82d9ba906"
        },
        {
          "key": "solutionScavengerHash",
          "value": "c65363ed8f6af5d5bd5d9fc9f955106fb7f3356cb218f939a5b658d8a46365a8"
        },
        {
          "key": "action",
          "value": "CommitSolution"
        }
      ]
    }
  ]
} 
```

您会注意到`solutionHash`与之前的匹配。我们还为`solutionScavengerHash`创建了一个新的散列，它是解决方案和我们的帐户地址的组合。我们也可以通过直接查询来确保提交已经完成:

```js
scavengeCLI q scavenge commited "A stick" $(scavengeCLI keys show you -a) 
```

希望您能看到类似这样的内容:

```js
{
  "scavenger": "cosmos1m9pxr3nrra2cl07kh8hzdty5x0mejf44997f79",
  "solutionHash": "2f9457a6e8fb202f9e10389a143a383106268c460743dd59d723c0f82d9ba906",
  "solutionScavengerHash": "c65363ed8f6af5d5bd5d9fc9f955106fb7f3356cb218f939a5b658d8a46365a8"
}
```

这确认您的提交已成功提交，正在等待后续披露。要创建该命令，让我们首先使用`scavengeCLI tx scavenge revealSolution --help`检查`--help`命令。这将显示以下屏幕:

```js
Reveals a solution for scavenge

Usage:
  scavengeCLI tx scavenge revealSolution [solution] [flags]

Flags:
  -a, --account-number uint     The account number of the signing account (offline mode only)
  -b, --broadcast-mode string   Transaction broadcasting mode (sync|async|block) (default "sync")
      --dry-run                 ignore the --gas flag and perform a simulation of a transaction, but don't broadcast it
      --fees string             Fees to pay along with transaction; eg: 10uatom
      --from string             Name or address of private key with which to sign
      --gas string              gas limit to set per-transaction; set to "auto" to calculate required gas automatically (default 200000) (default "200000")
      --gas-adjustment float    adjustment factor to be multiplied against the estimate returned by the tx simulation; if the gas limit is set manually this flag is ignored  (default 1)
      --gas-prices string       Gas prices to determine the transaction fee (e.g. 10uatom)
      --generate-only           Build an unsigned transaction and write it to STDOUT (when enabled, the local Keybase is not accessible and the node operates offline)
  -h, --help                    help for revealSolution
      --indent                  Add indent to JSON response
      --ledger                  Use a connected Ledger device
      --memo string             Memo to send along with transaction
      --node string             <host>:<port> to tendermint rpc interface for this chain (default "tcp://localhost:26657")
  -s, --sequence uint           The sequence number of the signing account (offline mode only)
      --trust-node              Trust connected full node (don't verify proofs for responses) (default true)
  -y, --yes                     Skip tx broadcasting prompt confirmation

Global Flags:
      --chain-id string   Chain ID of tendermint node
  -e, --encoding string   Binary encoding (hex|b64|btc) (default "hex")
      --home string       directory for config and data (default "/home/billy/.scavengeCLI")
  -o, --output string     Output format (text|json) (default "text")
      --trace             print out full stack trace on errors 
```

因为我们需要的只是解决方案，所以让我们再次发送并确认我们的最终信息:

```js
scavengeCLI tx scavenge revealSolution "A stick" --from you 
```

我们可以收集`txhash`并使用`scavengeCLI q tx <txhash>`再次查询它以揭示:

```js
{
  "height": "2810",
  "txhash": "086B122735C728B2556E04D537E53D6C91C3B46CE0ED0BB6C5001006A4BD2B0F",
  "raw_log": "[{\"msg_index\":0,\"success\":true,\"log\":\"\",\"events\":[{\"type\":\"message\",\"attributes\":[{\"key\":\"sender\",\"value\":\"cosmos13aupkh5020l9u6qquf7lvtcxhtr5jjama2kwyg\"},{\"key\":\"module\",\"value\":\"scavenge\"},{\"key\":\"action\",\"value\":\"SolveScavenge\"},{\"key\":\"sender\",\"value\":\"cosmos1m9pxr3nrra2cl07kh8hzdty5x0mejf44997f79\"},{\"key\":\"solutionHash\",\"value\":\"2f9457a6e8fb202f9e10389a143a383106268c460743dd59d723c0f82d9ba906\"},{\"key\":\"description\",\"value\":\"What's brown and sticky?\"},{\"key\":\"solution\",\"value\":\"A stick\"},{\"key\":\"scavenger\",\"value\":\"cosmos1m9pxr3nrra2cl07kh8hzdty5x0mejf44997f79\"},{\"key\":\"reward\",\"value\":\"69foo\"},{\"key\":\"action\",\"value\":\"RevealSolution\"}]},{\"type\":\"transfer\",\"attributes\":[{\"key\":\"recipient\",\"value\":\"cosmos1m9pxr3nrra2cl07kh8hzdty5x0mejf44997f79\"},{\"key\":\"amount\",\"value\":\"69foo\"}]}]}]",
  "logs": [
    {
      "msg_index": 0,
      "success": true,
      "log": "",
      "events": [
        {
          "type": "message",
          "attributes": [
            {
              "key": "sender",
              "value": "cosmos13aupkh5020l9u6qquf7lvtcxhtr5jjama2kwyg"
            },
            {
              "key": "module",
              "value": "scavenge"
            },
            {
              "key": "action",
              "value": "SolveScavenge"
            },
            {
              "key": "sender",
              "value": "cosmos1m9pxr3nrra2cl07kh8hzdty5x0mejf44997f79"
            },
            {
              "key": "solutionHash",
              "value": "2f9457a6e8fb202f9e10389a143a383106268c460743dd59d723c0f82d9ba906"
            },
            {
              "key": "description",
              "value": "What's brown and sticky?"
            },
            {
              "key": "solution",
              "value": "A stick"
            },
            {
              "key": "scavenger",
              "value": "cosmos1m9pxr3nrra2cl07kh8hzdty5x0mejf44997f79"
            },
            {
              "key": "reward",
              "value": "69foo"
            },
            {
              "key": "action",
              "value": "RevealSolution"
            }
          ]
        },
        {
          "type": "transfer",
          "attributes": [
            {
              "key": "recipient",
              "value": "cosmos1m9pxr3nrra2cl07kh8hzdty5x0mejf44997f79"
            },
            {
              "key": "amount",
              "value": "69foo"
            }
          ]
        }
      ]
    }
  ],
  "gas_wanted": "200000",
  "gas_used": "30740",
  "tx": {
    "type": "cosmos-sdk/StdTx",
    "value": {
      "msg": [
        {
          "type": "scavenge/RevealSolution",
          "value": {
            "scavenger": "cosmos1m9pxr3nrra2cl07kh8hzdty5x0mejf44997f79",
            "solutionHash": "2f9457a6e8fb202f9e10389a143a383106268c460743dd59d723c0f82d9ba906",
            "solution": "A stick"
          }
        }
      ],
      "fee": {
        "amount": [],
        "gas": "200000"
      },
      "signatures": [
        {
          "pub_key": {
            "type": "tendermint/PubKeySecp256k1",
            "value": "AxHwDfJwPnyoTrt5o8L7iSCiUzIOsCOPovWicfgAyIZp"
          },
          "signature": "w0wgQzYL2OeNYsnSJ3WwQo9tNv3RC+Qu6Oo+AdsyFDduASZ4p4vioBxGq/iMn4bNOG5mCKS6eUJZmHN0x6gx9g=="
        }
      ],
      "memo": ""
    }
  },
  "timestamp": "2020-01-18T17:53:21Z",
  "events": [
    {
      "type": "message",
      "attributes": [
        {
          "key": "sender",
          "value": "cosmos13aupkh5020l9u6qquf7lvtcxhtr5jjama2kwyg"
        },
        {
          "key": "module",
          "value": "scavenge"
        },
        {
          "key": "action",
          "value": "SolveScavenge"
        },
        {
          "key": "sender",
          "value": "cosmos1m9pxr3nrra2cl07kh8hzdty5x0mejf44997f79"
        },
        {
          "key": "solutionHash",
          "value": "2f9457a6e8fb202f9e10389a143a383106268c460743dd59d723c0f82d9ba906"
        },
        {
          "key": "description",
          "value": "What's brown and sticky?"
        },
        {
          "key": "solution",
          "value": "A stick"
        },
        {
          "key": "scavenger",
          "value": "cosmos1m9pxr3nrra2cl07kh8hzdty5x0mejf44997f79"
        },
        {
          "key": "reward",
          "value": "69foo"
        },
        {
          "key": "action",
          "value": "RevealSolution"
        }
      ]
    },
    {
      "type": "transfer",
      "attributes": [
        {
          "key": "recipient",
          "value": "cosmos1m9pxr3nrra2cl07kh8hzdty5x0mejf44997f79"
        },
        {
          "key": "amount",
          "value": "69foo"
        }
      ]
    }
  ]
}
```

您会注意到提交的最后一个事件是一个传输。这显示了奖励进入用户账户`you`的移动。要确认`you`现在有更多的`69foo`，您可以按如下方式查询他们的账户余额:

```js
scavengeCLI q account $(scavengeCLI keys show you -a) 
```

这应该显示出健康的账户余额`70foo`，因为`you`从`1foo`开始:

```js
{
  "type": "cosmos-sdk/Account",
  "value": {
    "address": "cosmos1m9pxr3nrra2cl07kh8hzdty5x0mejf44997f79",
    "coins": [
      {
        "denom": "foo",
        "amount": "70"
      }
    ],
    "public_key": {
      "type": "tendermint/PubKeySecp256k1",
      "value": "AxHwDfJwPnyoTrt5o8L7iSCiUzIOsCOPovWicfgAyIZp"
    },
    "account_number": "1",
    "sequence": "5"
  }
}
```

如果您想看一看完成的清理，您可以首先使用以下命令查询所有清理:

```js
scavengeCLI q scavenge list 
```

要查看具体的一个，只需使用:

```js
scavengeCLI q scavenge get 2f9457a6e8fb202f9e10389a143a383106268c460743dd59d723c0f82d9ba906 
```

这应该向您显示清除实际上已经完成:

```js
{
  "creator": "cosmos1uajgdapslnsthwscpy474t3k69u0r8z3u0aaer",
  "description": "What's brown and sticky?",
  "solutionHash": "2f9457a6e8fb202f9e10389a143a383106268c460743dd59d723c0f82d9ba906",
  "reward": [
    {
      "denom": "foo",
      "amount": "69"
    }
  ],
  "solution": "A stick",
  "scavenger": "cosmos1m9pxr3nrra2cl07kh8hzdty5x0mejf44997f79"
}
```

# 结论

**感谢和我一起**构建一个确定性状态机，并把它作为一个游戏来使用。我希望你可以看到，即使是这样一个简单的应用程序也可以非常强大，因为它包含了数字稀缺性。

如果您想继续，请考虑通过执行以下操作之一来扩展该应用程序的功能:

*   允许`Scavenge`的`Creator`编辑或删除清除。
*   创建一个列出所有提交的查询。

如果您有兴趣了解更多关于 Cosmos SDK 的信息，请查看我们的其他[文档](https://docs.cosmos.network/)或加入我们的[论坛](https://forum.cosmos.network/)。

# 后续步骤

未来教程中需要关注的主题有:

*   [应用程序之间的通信(IBC)](https://cosmos.network/ibc/)
*   [数字收藏品(NFTs)](https://github.com/cosmos/modules)
*   [使用以太坊虚拟机(EVM)作为应用程序中的模块](https://github.com/chainsafe/ethermint)

如果你有任何问题或意见，欢迎在本教程的 [github](https://github.com/cosmos/sdk-tutorials) 上发表。

# 关于作者

如果你想和我保持联系，请关注我的 github(地址: [@okwme](https://github.com/okwme) )或 twitter(地址:[@ billyrenekamp](https://twitter.com/billyrennekamp))。