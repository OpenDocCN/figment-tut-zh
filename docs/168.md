# 介绍

> 原文:[https://github . com/fig ment-networks/learn-tutorials/blob/master/Solana/Solana-streaming-protocol . MD](https://github.com/figment-networks/learn-tutorials/blob/master/solana/solana-streaming-protocol.md)

实时流可以理解为资产在一段时间内不断从一个钱包流向另一个钱包。它简化了交易，也实现了无信任的环境。订阅服务或自由职业者可以使用流媒体交易来维护其客户的不信任环境。这个概念有很多用途。可以看看以太坊网络上搭建的[超流](https://www.superfluid.finance/home)协议作为例子。本教程由三部分组成。首先，我们将编写一个 Solana 程序来处理流，然后我们将为我们的协议创建一个后端。最后，我们将把它与我们的前端连接起来。

# 先决条件

要掌握本教程的内容，需要很好地理解 [Rust](https://www.rust-lang.org/) 编程语言和 [React](https://reactjs.org/) 和 [Redux](https://redux.js.org/) 。

# 要求

完成本教程需要以下软件:

*   Git，从[这里](https://git-scm.com/downloads)安装。
*   Solana CLI，从[这里](https://docs.solana.com/cli/install-solana-cli-tools#use-solanas-install-tool)安装。
*   索拉纳钱包
*   防锈工具链，从[处安装到](https://www.rust-lang.org/tools/install)处。
*   Node.js (v14.18.1+)，从[这里](https://nodejs.org/en/download/)安装。
*   从[安装到](https://www.postgresql.org/)

我们将分 3 个部分来编写教程。首先，我们将编写我们的 Solana 程序，然后我们将为我们的协议创建后端，最后，我们将把它与我们的前端连接起来。

# 索拉纳计划

在进入编码之前，让我们简单回顾一下什么是**流协议**以及我们需要在 Solana 程序中创建什么指令。一个**流媒体协议**创建了一个托管账户，它将在时间的帮助下跟踪双方的余额。最初，托管账户中的所有资金将归发送方所有。久而久之，一些资金的所有权将转移到接收人，这意味着接收人可以提取这些资金。

我们将需要在我们的索拉纳程序 3 指令

*   **创建一个流**:这可以用于发送者，他们将资助我们的托管账户，提供有关接收者的信息，并定义流的开始和结束时间。
*   **提取资金**:接收方可以用它来提取自己已经赚到的资金。
*   **取消流**:发送方可以用它来取消流。该指令将把托管账户中的自有资金分配给发送方和接收方账户。

让我们开始创建我们的程序吧！在项目文件夹中打开一个终端，运行以下命令，使用库模板创建一个新的 Rust 项目:

```
cargo new --lib sol-stream-program 
```

我们现在可以在项目目录中看到`sol-stream-program`文件夹，这样我们就可以在代码编辑器中打开它。我在本教程中使用 Visual Studio 代码(通常称为 VSCode)。您可以使用自己选择的代码编辑器——在`Cargo.toml`文件中，添加所需的依赖项:

```
[package]
name = "sol-stream-program"
version = "0.1.0"
edition = "2018"

[dependencies]
solana-program = "=1.8.1"
borsh = "0.9.1"
thiserror = "1.0.24"

[dev-dependencies]
solana-program-test = "=1.8.1"
solana-sdk = "=1.8.1"

[lib]
crate-type = ["cdylib", "lib"]
```

现在要下载所有的板条箱，我们可以保存`Cargo.toml`文件并在终端运行:

```
cargo check 
```

我们将创建具有以下结构的程序:

```
├─ src
│  ├─ lib.rs -> registering modules
│  ├─ entrypoint.rs -> entrypoint to the program
│  ├─ instruction.rs -> program API, (de)serializing instruction data
│  ├─ processor.rs -> program logic
│  ├─ state.rs -> program objects, (de)serializing state
│  ├─ error.rs -> program specific errors
├─ .gitignore
├─ Cargo.lock
├─ Cargo.toml 
```

使用这种结构的程序流程如下所示:

1.  有人称入口点
2.  入口点将参数转发给处理器
3.  处理器要求`instruction.rs`解码来自 entrypoint 函数的`instruction_data`参数。
4.  使用解码的数据，处理器现在将决定使用哪个处理函数来处理请求。
5.  处理器可以使用`state.rs`将状态编码到或解码已经传递到入口点的账户的状态。

`instruction.rs`中的代码定义了程序的 API。

现在让我们在`sol-stream-program/src`目录下创建`entrypoint.rs`、`instruction.rs`、`processor.rs`、`state.rs`和`error.rs`文件。我们可以在`lib.rs`中注册新创建的文件，方法是更新它以包含模块:

```
pub mod error;
pub mod instruction;
pub mod native_mint;
pub mod processor;
pub mod state;
pub mod entrypoint;
```

现在，在`src/entrypoint.rs`文件中，让我们添加入口点函数的代码，并使用`entrypoint!`宏注册它:

```
//! Program entrypoint

use solana_program::{
    account_info::AccountInfo, entrypoint, entrypoint::ProgramResult,
    program_error::PrintProgramError, pubkey::Pubkey,
};

fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    Ok(())
}
entrypoint!(process_instruction);
```

我们正在从`solana_program`箱中导入所需的结构、函数和宏。然后，我们创建一个函数，它将 program_id、accounts 和 instruction_data 作为输入参数，并返回一个 ProgramResult。然后我们用最后一行的`entrypoint!`宏注册这个函数。

现在让我们打开`instruction.rs`并添加以下代码:

```
use borsh::BorshDeserialize;
use solana_program::program_error::ProgramError;

/// Instructions supported by the sol-streaming program.
#[repr(C)]
#[derive(Clone, Debug, PartialEq)]
pub enum StreamInstruction {
    /// Create a stream with a escrow account created and funded by sender
    /// account should have a total_lamport=admin_cut+program_rent_account+amount_to_send.
    ///
    /// Accounts expected:
    ///
    /// `[writable]` escrow account, it will hold all necessary info about the trade.
    /// `[signer]` sender account
    /// `[]` receiver account
    /// `[]` Admin account
    CreateStream,

    /// Withdraw from a stream for receiver
    ///
    /// Accounts expected:
    ///
    /// `[writable]` escrow account, it will hold all necessary info about the trade.
    /// `[signer]` receiver account
    WithdrawFromStream,

    /// Close a stream and transfer tokens between sender and receiver.
    ///
    /// Accounts expected:
    ///
    /// `[writable]` escrow account, it will hold all necessary info about the trade.
    /// `[signer]` sender account
    /// `[]` receiver account
    CloseStream,
}
```

注意，`CreateStream`和`WithdrawFromStream`需要来自发起者的一些输入，让我们在`state.rs`中为它们创建结构。在`state.rs`中添加以下代码:

```
use borsh::{BorshDeserialize, BorshSerialize};
use solana_program::{clock::UnixTimestamp, pubkey::Pubkey};

#[derive(Clone, Debug, PartialEq, BorshDeserialize, BorshSerialize)]
pub struct CreateStreamInput {
    pub start_time: UnixTimestamp,
    pub end_time: UnixTimestamp,
    pub receiver: Pubkey,
    pub lamports_withdrawn: u64,
    pub amount_second: u64,
}

#[derive(Clone, Debug, PartialEq, BorshDeserialize, BorshSerialize)]
pub struct WithdrawInput {
    pub amount: u64,
}
```

对于`CreateStream`,我们将需要`CreateStreamInput`结构:

*   `start_time`:流开始的 [Unix 时间戳](https://en.wikipedia.org/wiki/Unix_time)。
*   `end_time`:流结束的 [Unix 时间戳](https://en.wikipedia.org/wiki/Unix_time)。
*   `receiver`:接收方的公钥。
*   我们允许接收方在拥有所有权的情况下撤回港口，我们也希望记录撤回港口的数量以供计算。
*   `amount_speed`:每秒传输到接收器的灯数。

对于`WithdrawFromStream`,我们将需要`WithdrawInput`结构:

*   接收者想要撤回的灯的数量。

现在让我们将这些结构导入到`instruction.rs`中并使用它们，在文件的最顶端添加这一行:

```
use crate::state::{CreateStreamInput, WithdrawInput};
```

将`CreateStream`和`WithdrawFromStream`更新为:

```
// CreateStream,
CreateStream(CreateStreamInput),
```

```
// WithdrawFromStream
WithdrawFromStream(WithdrawInput)
```

作为参考，可以在这里查看文件[。](https://github.com/SushantChandla/sol-stream-program/blob/main/src/instruction.rs)

现在我们的枚举已经完成，让我们添加一个函数来解包给我们程序的指令。`instruction.rs`结束时:

```
impl StreamInstruction {
    pub fn unpack(instruction_data: &[u8]) -> Result<Self, ProgramError> {
        let (tag, data) = instruction_data
            .split_first()
            .ok_or(ProgramError::InvalidInstructionData)?;
        match tag {
            1 => Ok(StreamInstruction::CreateStream(
                CreateStreamInput::try_from_slice(data)?,
            )),
            2 => Ok(StreamInstruction::WithdrawFromStream(
                WithdrawInput::try_from_slice(data)?,
            )),
            3 => Ok(StreamInstruction::CloseStream),
            _ => Err(ProgramError::InvalidInstructionData),
        }
    }
}
```

因为只有一个入口点，所以我们添加了一个解包数据的函数。我们使用了`instruction_data`的第一个元素作为标签。然后我们使用了`BorshDeserialization`派生，它为我们提供了`try_from_slice`函数来解包数据。我们正在使用:

*   标签 1 ->创建流指令。
*   标签 2 ->撤回指令。
*   标签 3 ->关闭流指令。

否则返回一个错误。现在我们可以打开`processor.rs`文件并在其中添加指令逻辑。

```
use std::str::FromStr;

use crate::{
    instruction::StreamInstruction,
    state::{CreateStreamInput, StreamData, WithdrawInput},
};
use borsh::{BorshDeserialize, BorshSerialize};
use solana_program::{
    account_info::{next_account_info, AccountInfo},
    clock::Clock,
    entrypoint::ProgramResult,
    program_error::ProgramError,
    pubkey::Pubkey,
    sysvar::{rent::Rent, Sysvar},
};
pub struct Processor;

impl Processor {
    pub fn process(
        program_id: &Pubkey,
        accounts: &[AccountInfo],
        instruction_data: &[u8],
    ) -> ProgramResult {
        let instruction = StreamInstruction::unpack(instruction_data)?;

        match instruction {
            StreamInstruction::CreateStream(data) => todo!(),
            StreamInstruction::WithdrawFromStream(data) =>todo!(),
            StreamInstruction::CloseStream => todo!(),
        }
    }
}
```

我们已经从`solana_program`箱中导入了所需的结构和函数。然后，我们将创建一个名为`Processor`的结构，并通过创建一个名为`process`的函数来实现它，该函数将输入:

*   `program_id`:节目的节目 ID。
*   `accounts`:交易通过的账户。
*   `instruction_data`:为指令传递的指令数据。

该函数将返回`ProgramResult`。在函数中，我们使用在`StreamInstruction`枚举上创建的解包函数解包了`instruction_data`。我们已经使用了`?`操作符来展开有效值或返回错误值，并将它们传播给调用函数。然后我们在指令上使用了一个匹配语句，并通过给每个指令添加`todo!()`宏来删除它们。

在我们继续定义指令之前，让我们更新一下`entrypoint.rs`文件。

```
use crate::processor::Processor;
fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    Processor::process(program_id, accounts, instruction_data)
}
```

我们已经导入了`Processor`并更新了函数来调用传递相同参数的`process`函数。作为参考，你可以在这里查看文件[。](https://github.com/SushantChandla/sol-stream-program/blob/main/src/processor.rs)

现在让我们去`processor.rs`并删除 todos。对于每条指令，我们将创建一个函数，并在其中写入逻辑。

将`processor.rs`中的代码更新为:

```
impl Processor {
    pub fn process(
        program_id: &Pubkey,
        accounts: &[AccountInfo],
        instruction_data: &[u8],
    ) -> ProgramResult {
        let instruction = StreamInstruction::unpack(instruction_data)?;

        match instruction {
            StreamInstruction::CreateStream(data) => {
                Self::process_create_stream(program_id, accounts, data)
            }
            StreamInstruction::WithdrawFromStream(data) => {
                Self::process_withdraw(program_id, accounts, data)
            }
            StreamInstruction::CloseStream => Self::process_close(program_id, accounts),
        }
    }

    fn process_create_stream(
        _program_id: &Pubkey,
        accounts: &[AccountInfo],
        data: CreateStreamInput,
    ) -> ProgramResult {
        Ok(())
    }

    fn process_withdraw(
        _program_id: &Pubkey,
        accounts: &[AccountInfo],
        data: WithdrawInput,
    ) -> ProgramResult {
        Ok(())
    }

    fn process_close(_program_id: &Pubkey, accounts: &[AccountInfo]) -> ProgramResult {
        Ok(())
    }
}
```

我们已经创建了空函数`process_create_stream`、`process_withdraw`和`process_close`。`process_create_stream`和`process_withdraw`函数有一个参数`data`，分别是结构`CreateStreamInput`和`WithdrawInput`。

现在让我们打开`errors.rs`并写下我们的程序在某些情况下可能返回的错误。

```
use thiserror::Error;
use solana_program::{msg, program_error::ProgramError};

#[derive(Error, Debug, Copy, Clone)]
pub enum StreamError {
    #[error("Failed to parse the pubkey")]
    PubKeyParseError,
    #[error("Admin account invalid")]
    AdminAccountInvalid,
    #[error("Not enough lamports in account")]
    NotEnoughLamports,
    #[error("Start time or end time for the stream is invalid")]
    InvalidStartOrEndTime,
    #[error("Receiver does not own enough tokens")]
    WithdrawError,
}

impl From<StreamError> for ProgramError {
    fn from(e: StreamError) -> Self {
         msg!("{}", e);
        ProgramError::Custom(e as u32)
    }
}
```

作为参考，可以在这里查看文件[。](https://github.com/SushantChandla/sol-stream-program/blob/main/src/error.rs)

## 写作指令逻辑

现在我们可以再次打开`processor.rs`文件，完成`process_create_stream`、`process_withdraw`和`process_close`功能。

**process_create_stream** 我们将解析 admin 的公钥。我在这里使用了我的公钥作为例子，但是你也可以使用你的公钥。我们使用的是`from_str`方法。如果出现错误，我们返回在`errors.rs`中定义的`PubKeyParseError`。

然后我们会得到所有的账户。首先我们创建一个迭代器，然后我们可以使用`next_account_info`函数来获取所有的账户。我们将使用相应的变量名存储所有帐户。

现在，我们可以通过将它的密钥与我们在函数中提供的 pubkey 进行比较来检查所提供的 admin 帐户是否正确。如果不正确，我们返回一个错误。

```
// Updated at top of file.
use crate::{
    error::StreamError,
    instruction::StreamInstruction,
    state::{CreateStreamInput, StreamData, WithdrawInput},
};
    ...
    fn process_create_stream(
        _program_id: &Pubkey,
        accounts: &[AccountInfo],
        data: CreateStreamInput,
    ) -> ProgramResult {
        let admin_pub_key = match Pubkey::from_str("DGqXoguiJnAy8ExJe9NuZpWrnQMCV14SdEdiMEdCfpmB") {
            Ok(key) => key,
            Err(_) => return Err(StreamError::PubKeyParseError.into()),
        };

        let account_info_iter = &mut accounts.iter();
        let escrow_account = next_account_info(account_info_iter)?;
        let sender_account = next_account_info(account_info_iter)?;
        let receiver_account = next_account_info(account_info_iter)?;
        let admin_account = next_account_info(account_info_iter)?;

        if *admin_account.key != admin_pub_key {
            return Err(StreamError::AdminAccountInvalid.into());
        }
```

现在，我们可以进行 0.03 lamports(任意数量)的交易，并将这些交易发送到 admin 帐户。

> 注意:事务是原子的，如果程序失败，整个事务将被恢复。

现在，我们可以检查给定的指令数据。当我们检查结束时间时，它不应该早于开始时间，开始时间也不应该早于当前时间。我们可以通过使用`Clock::get()?.unix_timestamp`得到当前的`unix_timestamp`。如果失败，我们将返回一个`InvalidStartOrEndTime`错误。

然后，我们可以检查存放在帐户中的 Lamport 总数应该等于我们要发送的金额+在链上创建帐户所需的最小租金数。我们可以通过使用`Rent::get()?.minimum_balance(len)`方法得到所需的最小余额。如果失败，我们可以返回`NotEnoughLamports`错误。

```
        // 0.03 sol token admin account fee
        // 30000000 Lamports = 0.03 sol
        **escrow_account.try_borrow_mut_lamports()? -= 30000000;
        **admin_account.try_borrow_mut_lamports()? += 30000000;

        if data.end_time <= data.start_time || data.start_time < Clock::get()?.unix_timestamp {
            return Err(StreamError::InvalidStartOrEndTime.into());
        }

        if data.amount_second * ((data.end_time - data.start_time) as u64)
            != **escrow_account.lamports.borrow()
                - Rent::get()?.minimum_balance(escrow_account.data_len())
        {
            return Err(StreamError::NotEnoughLamports.into());
        }
```

然后我们会检查这个交易是谁签的，接收方的公钥等于提供给我们的账户。

```
        if !sender_account.is_signer {
            return Err(ProgramError::MissingRequiredSignature);
        }

        if *receiver_account.key != data.receiver {
            return Err(ProgramError::InvalidAccountData);
        }
```

现在，我们已经准备好将流数据写入我们的程序帐户。我们将创建一个`StreamData`结构，并将其存储在我们的托管账户中。在`state.rs`的末尾添加一个新的结构:

```
#[derive(Clone, Debug, PartialEq, BorshDeserialize, BorshSerialize)]
pub struct StreamData {
    pub start_time: UnixTimestamp,
    pub end_time: UnixTimestamp,
    pub receiver: Pubkey,
    pub lamports_withdrawn: u64,
    pub amount_second: u64,
    pub sender: Pubkey,
}

impl StreamData {
    pub fn new(data: CreateStreamInput, sender: Pubkey) -> Self {
        StreamData {
            start_time: data.start_time,
            end_time: data.end_time,
            receiver: data.receiver,
            lamports_withdrawn: 0,
            amount_second: data.amount_second,
            sender,
        }
    }
}
```

作为参考，可以在这里查看文件[。](https://github.com/SushantChandla/sol-stream-program/blob/main/src/state.rs)

我们添加了一个新方法，在`CreateStreamInput`和发送者公钥的帮助下创建该结构的实例。

现在让我们跳回`processor.rs`文件并完成该功能:

```
       let escrow_data = StreamData::new(data, *sender_account.key);

        escrow_data.serialize(&mut &mut escrow_account.data.borrow_mut()[..])?;
        Ok(())
    }
```

我们将首先创建`escrow_data`，然后在 borsh `serialize`方法的帮助下，我们可以将数据写入`escrow_account`。我们通过在函数结束时返回结果`Ok(())`来完成函数。

**流程 _ 撤销**

我们将账户存储到变量中，就像我们在`process_create_stream`函数中所做的那样。然后我们在`escrow_account`中反序列化数据，不是说这些数据是我们保存在`process_create_stream`函数中的。然后我们执行一个检查，这个账户的接收者是歌手，这个`escrow_account`属于他。

```
 fn process_withdraw(
        _program_id: &Pubkey,
        accounts: &[AccountInfo],
        data: WithdrawInput,
    ) -> ProgramResult {
        let account_info_iter = &mut accounts.iter();
        let escrow_account = next_account_info(account_info_iter)?;
        let receiver_account = next_account_info(account_info_iter)?;

        let mut escrow_data = StreamData::try_from_slice(&escrow_account.data.borrow())
            .expect("failed to serialize escrow data");

        if *receiver_account.key != escrow_data.receiver {
            return Err(ProgramError::IllegalOwner);
        }

        if !receiver_account.is_signer {
            return Err(ProgramError::MissingRequiredSignature);
        }
```

然后，我们可以检查用户是否可以撤回所需的灯。我们将获得当前时间，并计算他们拥有的港口总数。通过减去`lamports_withdrawn`，我们可以跟踪接收器已经撤回的灯。

```
        let time = Clock::get()?.unix_timestamp;

        let total_token_owned = escrow_data.amount_second
            * ((std::cmp::min(time, escrow_data.end_time) - escrow_data.start_time) as u64)
            - escrow_data.lamports_withdrawn;

        if data.amount > total_token_owned {
            return Err(StreamError::WithdrawError.into());
        }
```

现在我们可以继续交易，并将令牌发送给`receiver_account`。我们还将在`lamports_withdrawn`中增加一个值。我们通过将新的`escrow_data`写入`escrow_account`然后返回结果`Ok(())`来完成这个功能。

```
        **escrow_account.try_borrow_mut_lamports()? -= data.amount;
        **receiver_account.try_borrow_mut_lamports()? += data.amount;
        escrow_data.lamports_withdrawn += data.amount;

        escrow_data.serialize(&mut &mut escrow_account.data.borrow_mut()[..])?;
        Ok(())
    }
```

**流程 _ 关闭**

在这个函数中，我们也将获得帐户，并将它们存储在变量中。然后我们得到`escrow_data`，就像我们在`process_withdraw`函数中所做的一样。然后我们检查`sender_account`是否是`escrow_account`的所有者，以及`sender`是否签署了交易。

```
fn process_close(_program_id: &Pubkey, accounts: &[AccountInfo]) -> ProgramResult {
        let account_info_iter = &mut accounts.iter();
        let escrow_account = next_account_info(account_info_iter)?;
        let sender_account = next_account_info(account_info_iter)?;
        let receiver_account = next_account_info(account_info_iter)?;

        let mut escrow_data = StreamData::try_from_slice(&escrow_account.data.borrow())
            .expect("failed to serialize escrow data");

        if escrow_data.sender != *sender_account.key {
            return Err(ProgramError::IllegalOwner);
        }
        if !sender_account.is_signer {
            return Err(ProgramError::MissingRequiredSignature);
        }
```

我们正在关闭代管账户，所以我们想把资金转移到他们所拥有的收款人和汇款人。因此，我们可以计算接收者拥有的令牌总数。

```
        let time: i64 = Clock::get()?.unix_timestamp;
        let mut lamport_streamed_to_receiver: u64 = 0;

        if time > escrow_data.start_time {
            lamport_streamed_to_receiver = escrow_data.amount_second
                * ((std::cmp::min(time, escrow_data.end_time) - escrow_data.start_time) as u64)
                - escrow_data.lamports_withdrawn;
        }
```

现在我们有了接收者拥有的全部端口。我们可以将剩余的灯发送给发送者。最后，我们将`escrow_account`余额设置为 0，然后我们可以返回结果`Ok(())`。

```
        **receiver_account.try_borrow_mut_lamports()? += lamport_streamed_to_receiver;
        escrow_data.lamports_withdrawn += lamport_streamed_to_receiver;
        **sender_account.try_borrow_mut_lamports()? += **escrow_account.lamports.borrow();

        **escrow_account.try_borrow_mut_lamports()? = 0;

        Ok(())
    }
```

作为参考，可以在这里查看文件[。](https://github.com/SushantChandla/sol-stream-program/blob/main/src/processor.rs)

你可以在 [GitHub](https://github.com/SushantChandla/sol-stream-program) 上查看 Solana 程序的完整代码。

## 部署程序

现在，为了部署程序，我们可以使用下面的命令来创建一个构建。在这个命令中，manifest-path 应该是您的`Cargo.toml`文件的路径。这将以共享对象格式输出编译后的程序。所以)在`dist/program`目录中:

```
cargo build-bpf --manifest-path=Cargo.toml --bpf-out-dir=dist/program 
```

我们将创建一个新的 Solana 帐户来部署该计划。运行以下命令:

```
solana-keygen new -o keypair.json 
```

该命令将提示您输入密码以保护恢复种子短语:

```
Generating a new keypair

For added security, enter a BIP39 passphrase

NOTE! This passphrase improves security of the recovery seed phrase NOT the
keypair file itself, which is stored as insecure plain text

BIP39 Passphrase (empty for none): 
```

您可以选择一个密码或将其留空。继续将提供帐户的公钥和用于创建私钥的种子短语:

```
Wrote new keypair to keypair.json
=====================================================================
pubkey: 7WQDnydTTtyb2DsTuuFpeu2bDxQdpZMRc4R6qja1UzP
=====================================================================
Save this seed phrase and your BIP39 passphrase to recover your new keypair:
lemon avoid all erase chair acid fire govern glue outside wheel clock
===================================================================== 
```

一旦完成，你将会有一个`keypair.json`文件，包含一个新的 Solana 账户的私有和公共密钥。保证你的密钥对的安全是很重要的。不要将此文件提交给远程代码库。最好将这个文件添加到一个`.gitignore`中，以防止这种情况发生。

现在我们将请求在 Solana Devnet 上空投 SOL 令牌。此命令将向帐户添加 1 个 SOL 令牌:

```
solana airdrop 1 <YourPublicKey> --url https://api.devnet.solana.com 
```

例子

```
solana airdrop 1 7WQDnydTTtyb2DsTuuFpeu2bDxQdpZMRc4R6qja1UzP --url https://api.devnet.solana.com 
```

> 如果您得到一个错误:" **RPC 请求错误**:群集版本查询失败:发送对 URL(【https://api.devnet.solana.com/】T2)的请求时出错:尝试连接时出错:dns 错误:无法查找地址信息:未提供节点名或服务名，或者未知。"-请考虑将您的主 DNS 服务器切换到 Google、DNSWatch、OpenDNS、SAFEDNS、Dyn、Yandex、AdGuard 或 Cloudflare 之一。

如果你在部署的时候发现**余额不足**，你可以重新运行命令在 Devnet 上空投资金。

现在，我们将使用以下命令进行部署。请注意，在您的情况下，`keypair.json`和`dist/program/program.so`的路径可能不同。请检查，然后运行该命令。

```
solana deploy --keypair keypair.json dist/program/sol_stream_program.so --url https://api.devnet.solana.com 
```

我们将获得程序 id 作为输出。

```
Program Id: DcGPfiGbubEKh1EnQ86EdMvitjhrUo8fGSgvqtFG4A9t 
```

我们可以通过检查 Devnet 的 Solana Explorer 来验证部署。。我们可以搜索我们的计划 id 来查看任何相关的事务，包括部署。

# 后端

我们将在 [rocket web framework](https://rocket.rs/) 的帮助下创建我们的后端，但在我们开始编写后端代码之前，这将是一个了解我们为什么需要后端的好时机。

让我们考虑一个场景，在这个场景中，我们的协议没有后端。我们已经将所有数据存储在程序驱动账户(PDA)中，因此为了获取所有流，我们可以使用`@solana/web3.js`包中提供的`getProgramAccounts`函数，然后在`borsh`包的帮助下，我们将反序列化字节数据。然后，我们可以在所有 PDA 的数据中检查哪一个数据属于某个用户，即他们正在发送或接收。

现在让我们假设我们已经使我们的应用程序运行，它有大约 1000 个用户。如果所有用户都创建了 2 个流，这意味着我们将有 2000 个项目驱动的帐户！获取所有帐户只是为了显示每个用户的 2 个流会使我们的协议变慢，并且随着用户的增加，它变得不可用。

我们将使用我们的后端来索引我们的 PDA，并解决可扩展性问题。让我们再次创建一个 rust 项目，但这次使用默认模板，即二进制(应用程序)模板。打开项目文件夹中的控制台，并运行以下命令:

```
cargo new sol-stream-backend 
```

这将生成`sol-stream-backend`目录。我们现在可以在 VS-Code 上打开它了。现在，我们的项目看起来像这样:

```
├─ src
│  ├─ main.rs -> contain
├─ .gitignore
├─ Cargo.lock
├─ Cargo.toml 
```

现在打开`Cargo.toml`文件，更新它以添加所需的板条箱:

```
[package]
name = "sol-stream-backend"
version = "0.1.0"
edition = "2018"

[dependencies]
borsh = "0.9.1"
rocket = {version = "0.5.0-rc.1", features = ["tls", "json"]}
rocket_cors = {git = "https://github.com/lawliet89/rocket_cors", branch = "master"}
solana-client = "1.8.3"
solana-account-decoder = "1.8.3"
serde = "1.0.130"
solana-sdk = "1.8.3"
diesel = { version = "1.4.4", features = ["postgres"] }
dotenv = "0.15.0"
```

*   borsh:序列化和反序列化数据
*   rocket_cors:启用跨源资源共享
*   索拉纳客户端:获取索拉纳区块链上的所有程序账户
*   serde:用于 JSON 序列化和反序列化。
*   diesel:用于 SQL 查询构建
*   管理我们的数据库网址

我们将需要所有这些板条箱，要下载它们，我们可以保存`Cargo.toml`文件，并在终端运行:

```
cargo check 
```

现在让我们在`main.rs`中添加代码来创建一个“Hello world！”使用 rocket.rs 的路线

```
use rocket::{get, routes};

#[rocket::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let cors = rocket_cors::CorsOptions::default().to_cors()?;

    rocket::build()
        .mount("/", routes![index,route_with_pubkey])
        .attach(cors)
        .launch()
        .await?;

    Ok(())
}

#[get("/")]
fn index() -> &'static str {
    "Hello, world!"
}

#[get("/<pubkey>")]
fn route_with_pubkey(pubkey: &str)-> String{
    format!("Hello {}",pubkey)
}
```

在我解释这段代码之前，请在终端中运行以下命令:

```
cargo run 
```

它将编译并运行程序，然后我们可以在浏览器上打开`http://127.0.0.1:8000/`来查看:

[![browser image](../Images/13d21d37baf03e59128996eba3aa062e.png)T2】](https://github.com/figment-networks/learn-tutorials/raw/master/assets/image-solana-streaming-protocol-1.png?raw=true)

[![browser image](../Images/596e6a4ee7515b63aa49b9cde84bc1e3.png)T2】](https://github.com/figment-networks/learn-tutorials/raw/master/assets/image-solana-streaming-protocol-2.png?raw=true)

现在让我们看看是什么代码导致了这种情况。在第一行，我们已经从 rocket 导入了`routes`宏和`get`。我们将在函数中使用`#[rocket::main]`,它将把我们的函数转换成一个常规的 main 函数，该函数在内部初始化一个 Rocket-specific tokio 运行时，并在其中运行属性化的 async fn。

然后在函数内部，我们会在一个变量`cors`中得到默认的 cors (cors 代表跨对象资源共享)。这一行代码附加到我们的`cors`并将启动一个带有基础`"/"`的服务器，它将拥有将在`routes!`宏中传递的路由。如你所见，我们有两条路线，它们的功能分别叫做`index`和`route_with_pubkey`。我已经在宏观上超过了他们。然后我们等待这个调用并返回`Ok(())`,这样它就可以编译了。

现在来看看`index`和`route_with_pubkey`函数。我们在这里使用了`get`宏。对于`index`函数，我们将返回一个字符串“Hello world”。在`route_with_pubkey`的例子中，我们将从 URL 获取 pubkey 并返回“Hello”。

> 注意:你可以使用 mac 上的`cmd+c`和 windows 上的`control+c`来停止正在运行的服务器。

现在让我们安装`diesel` CLI。我们可以通过运行以下命令来实现:

```
cargo install diesel_cli --feature postgres 
```

> 如果您没有安装 Postgres，这将会失败。

现在，在我们的项目文件夹中，我们可以运行:

```
diesel setup 
```

现在运行以下命令来创建迁移:

```
diesel migration generate Stream 
```

这将创建一个名为`<Timestamp>_Stream`的迁移文件夹，包含`down.sql`和`up.sql`文件。

将`up.sql`文件更新为:

```
-- Your SQL goes here

Create Table streams(
   pda_account Varchar PRIMARY KEY,
    start_time BIGINT NOT NULL,
    end_time BIGINT NOT NULL,
    receiver Varchar Not NULL,
    lamports_withdrawn BIGINT NOT NULL,
    amount_second BIGINT NOT NULL,
    sender Varchar Not NULL,
    total_amount BIGINT NOT NULL
)
```

和`down.sql`文件:

```
-- This file should undo anything in `up.sql`
Drop Table streams
```

现在我们可以运行下面的命令来创建包含`diesel`所需模式的`src/schema.rs`文件:

```
diesel migration run 
```

现在我们可以运行下面的命令在我们的项目中创建一个包含数据库 URL 的`.env`文件。

```
DATABASE_URL=postgres://username:password@localhost/sol_stream_indexer > .env 
```

> 请注意，您必须更改这里的`username`和`password`。

我们将在下面构建我们的后端: [![backend-files](../Images/6274231cb213c9fcd794e57063c88d93.png)](https://github.com/figment-networks/learn-tutorials/raw/master/assets/image-solana-streaming-protocol-3.png)

在`src`目录中:

*   将包含主函数，我们将用它来添加所有的模块。
*   `models.rs`:将包含`Stream`和`StreamData`型号
*   `routes.rs`:将包含我们应用程序中的所有路线。
*   `schema.rs`:由 diesel cli 生成。
*   `solana.rs`:将包含一个功能，订阅索拉纳计划，并获得所有计划帐户。

创建空文件，让我们为我们的后端编写代码。

首先在`main.rs`顶部添加:

```
#[macro_use]
extern crate diesel;

mod models;
mod routes;
mod schema;
mod solana;
use rocket::routes;

use diesel::prelude::*;
use dotenv::dotenv;
use std::env;

pub fn establish_connection() -> PgConnection {
    dotenv().ok();
    let database_url = env::var("DATABASE_URL").expect("DATABASE_URL must be set");
    PgConnection::establish(&database_url)
        .unwrap_or_else(|_| panic!("Error connecting to {}", database_url))
}
```

我们为柴油添加了`#[macro_use]`。我们将创建一个函数，在 dotenv 的帮助下获得`database_url`。我们还没有在这里添加`main`功能，我们稍后会添加。

现在我们可以进入`models.rs`并添加:

```
use crate::diesel::ExpressionMethods;
use borsh::{BorshDeserialize, BorshSerialize};
use diesel::{Insertable, PgConnection, QueryDsl, Queryable, RunQueryDsl};
use serde::Serialize;
use solana_sdk::clock::UnixTimestamp;
use solana_sdk::pubkey::Pubkey;

use crate::schema::streams;

#[derive(Clone, Debug, PartialEq, BorshDeserialize, BorshSerialize)]
struct StreamData {
    pub start_time: UnixTimestamp,
    pub end_time: UnixTimestamp,
    pub receiver: Pubkey,
    pub lamports_withdrawn: u64,
    pub amount_second: u64,
    pub sender: Pubkey,
}

#[derive(Queryable, Insertable, Serialize)]
#[table_name = "streams"]
pub struct Stream {
    pub pda_account: String,
    pub start_time: i64,
    pub end_time: i64,
    pub receiver: String,
    pub lamports_withdrawn: i64,
    pub amount_second: i64,
    pub sender: String,
    pub total_amount: i64,
}
```

这里我们有两个结构，其中一个和我们程序中的`StreamData`和`Stream`相同

*   `StreamData`:用于从 PDA 账户获取数据。
*   这是我们希望存储在数据库中的结构。我们将使用`pda_account` PubKey 作为 ID。我们已经将`sender`和`receiver`的 pubkey 类型更改为`String`，因为我们可以在 Pubkey 上使用`.tostring`函数，与 i32 数组相比，它更容易存储在我们的数据库中。我们还从 diesel 中驱动了`Queryable`和`Insertable`，因此我们可以在 diesel 的帮助下生成查找、插入、更新和其他 SQL 查询。我们还从`serde`箱中驱动了`Serialize`将它转换成 JSON 格式。

现在我们需要在`Stream`上添加更多的函数，所以在文件末尾添加:

```
impl Stream {
    pub fn new(pda_pubkey: String, pda_data: &Vec<u8>) -> Option<Self> {
        let stream_data = match StreamData::try_from_slice(pda_data) {
            Ok(a) => a,
            Err(e) => {
                println!(
                    "Failed to deserialize {} with error {:?}",
                    pda_pubkey.to_string(),
                    e
                );
                return None;
            }
        };

        Some(Stream {
            sender: stream_data.sender.to_string(),
            end_time: stream_data.end_time,
            receiver: stream_data.receiver.to_string(),
            lamports_withdrawn: stream_data.lamports_withdrawn as i64,
            start_time: stream_data.start_time,
            total_amount: (stream_data.end_time - stream_data.start_time)
                * stream_data.amount_second as i64,
            pda_account: pda_pubkey,
            amount_second: stream_data.amount_second as i64,
        })
    }

    pub fn get_all_with_sender(pubkey: &String, conn: &PgConnection) -> Vec<Stream> {
        use crate::schema::streams::dsl::*;
        streams
            .filter(sender.eq(pubkey))
            .load::<Stream>(conn)
            .unwrap()
    }
    pub fn get_all_with_receiver(pubkey: &String, conn: &PgConnection) -> Vec<Stream> {
        use crate::schema::streams::dsl::*;
        streams
            .filter(receiver.eq(pubkey))
            .load::<Stream>(conn)
            .unwrap()
    }
    fn id_is_present(id: &String, conn: &PgConnection) -> bool {
        use crate::schema::streams::dsl::*;
        match streams.find(id).first::<Stream>(conn) {
            Ok(_s) => true,
            _ => false,
        }
    }
    pub fn insert_or_update(stream: Stream, conn: &PgConnection) -> bool {
        if Stream::id_is_present(&stream.pda_account, conn) {
            diesel::insert_into(crate::schema::streams::table)
                .values(&stream)
                .execute(conn)
                .is_ok()
        } else {
            use crate::schema::streams::dsl::{
                amount_second as a_s, end_time as e_t, lamports_withdrawn as l_w,
                pda_account as p_a, receiver as r, sender as s, streams, total_amount as t_a,
            };
            diesel::update(streams.find(stream.pda_account.clone()))
                .set((
                    a_s.eq(stream.amount_second),
                    e_t.eq(stream.end_time),
                    r.eq(stream.receiver),
                    p_a.eq(stream.pda_account),
                    s.eq(stream.sender),
                    l_w.eq(stream.lamports_withdrawn),
                    t_a.eq(stream.total_amount),
                    e_t.eq(stream.end_time),
                ))
                .execute(conn)
                .is_ok()
        }
    }
}
```

我们增加了以下功能:

*   `new`:借助`pda` pub key 和`pda`数据创建新的`Stream`的功能。我们首先在`borsh`箱子的帮助下创建`StreamData`，然后我们可以创建一个返回`Stream`。

*   `get_all_with_sender`:获取发送方等于给定公钥的所有流的函数。

*   `get_all_with_receiver`:获取接收者等于给定公钥的所有流的函数。

*   `id_is_present`:检查数据库是否包含特定 id 的函数。

*   `insert_or_update`:如果`id`不存在，函数`insert`一个新的流，我们可以用`id_is_present`函数和`update`检查它是否存在。

如果你想了解更多关于 diesel 的信息，你可以阅读[这里](https://diesel.rs/guides/getting-started)。

现在我们可以转到`src/solana.rs`文件:

我们在这个文件中添加了三个函数。

```
use std::{str::FromStr, thread};

use solana_client::{pubsub_client, rpc_client::RpcClient};
use solana_sdk::{account::Account, pubkey::Pubkey};

use crate::{establish_connection, models::Stream};

pub fn get_all_program_accounts() -> Vec<(Pubkey, Account)> {
    let program_pub_key = Pubkey::from_str("DcGPfiGbubEKh1EnQ86EdMvitjhrUo8fGSgvqtFG4A9t")
        .expect("program address invalid");
    let url = "https://api.devnet.solana.com".to_string();
    let client = RpcClient::new(url);

    client
        .get_program_accounts(&program_pub_key)
        .expect("Something went wrong")
}

pub fn subscribe_to_program() {
    let url = "ws://api.devnet.solana.com".to_string();
    let program_pub_key = Pubkey::from_str("DcGPfiGbubEKh1EnQ86EdMvitjhrUo8fGSgvqtFG4A9t")
        .expect("program address invalid");

    thread::spawn(move || loop {
        let subscription =
            pubsub_client::PubsubClient::program_subscribe(&url, &program_pub_key, None)
                .expect("Something went wrong");
        let conn = establish_connection();

        loop {
            let response = subscription.1.recv();
            match response {
                Ok(response) => {
                    let pda_pubkey = response.value.pubkey;
                    let pda_account: Account = response.value.account.decode().unwrap();

                    let stream = Stream::new(pda_pubkey, &pda_account.data);
                    match stream {
                        Some(a) => Stream::insert_or_update(a, &conn),
                        _ => {
                            println!("data didn't parsed");
                            continue;
                        }
                    };
                }
                Err(_) => {
                    break;
                }
            }
        }
        get_accounts_and_update()
    });
}

pub fn get_accounts_and_update() {
    let program_accounts = get_all_program_accounts();
    let conn = establish_connection();
    for item in program_accounts.iter() {
        let stream = Stream::new(item.0.to_string(), &item.1.data);
        match stream {
            Some(a) => Stream::insert_or_update(a, &conn),
            _ => continue,
        };
    }
}
```

*   `get_all_program_accounts`:函数将返回一个程序拥有的所有程序账号。
*   `subscribe_to_program`:订阅程序的功能，当任何程序拥有的帐户有更新时，该功能会通知我们。
*   `get_accounts_and_update`:函数获取所有的程序帐户，并填写插入或更新他们在我们的数据库中。

> 注意:`pubsub_client`有一个[问题](https://github.com/solana-labs/solana/issues/16102)仍在 WIP 中，因此我们遗漏了一些通知。

你可以在这里阅读索拉纳 RPC。

在`subscribe_to_program`中，我们生成了一个线程来监听我们将收到的更新，如果我们收到一个错误，我们将再次调用该函数。对于 For 循环中的每个通知，我们已经在`RPC Notification`的帮助下创建了流，您可以在这里看到[的 JSON 模式。然后我们调用了在模型中创建的`insert_or_update`函数。](https://docs.solana.com/developing/clients/jsonrpc-api#notification-format-2)

现在我们来看一下`src/routes.rs`:

```
use std::str::FromStr;
use rocket::get;
use rocket::serde::json::serde_json::json;
use rocket::serde::json::{Json, Value};

use crate::establish_connection;
use crate::models::Stream;

#[get("/")]
pub fn index() -> &'static str {
    "Hello, world!"
}

#[get("/<pubkey>")]
pub fn get_all_stream(pubkey: &str) -> Json<Value> {
    let pubkey_string = String::from_str(pubkey).unwrap();
    let conn = establish_connection();
    Json(
        json!({"status":"success","sending":Stream::use std::str::FromStr;

use rocket::get;
use rocket::serde::json::serde_json::json;
use rocket::serde::json::{Json, Value};

use crate::establish_connection;
use crate::models::Stream;

#[get("/")]
pub fn index() -> &'static str {
    "Hello, world!"
}

#[get("/<pubkey>")]
pub fn get_all_stream(pubkey: &str) -> Json<Value> {
    let pubkey_string = String::from_str(pubkey).unwrap();
    let conn = establish_connection();
    Json(
        json!({"status":"success","sending":Stream::get_all_with_sender(&pubkey_string, &conn),"receiving":Stream::get_all_with_receiver(&pubkey_string, &conn)}),
    )
}
```

我们添加了创建两个函数`index`函数与我们在 rocket 示例中的相同。

*   `get_all_stream`:这个函数将返回 Json 响应，我们使用`get_all_with_sender`和`get_all_with_receiver`函数从我们的索引表中获取它们。

现在让我们转到`src/main.rs`并添加主函数。在文件顶部添加以下代码:

```
use solana::get_all_program_accounts;
use solana::subscribe_to_program;

use crate::models::Stream;
use crate::routes::get_all_stream;
use crate::routes::index;
```

现在添加`main`功能:

```
#[rocket::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let program_accounts = get_all_program_accounts();
    let conn = establish_connection();
    for item in program_accounts.iter() {
        let stream = Stream::new(item.0.to_string(), &item.1.data);
        match stream {
            Some(a) => Stream::insert_or_update(a, &conn),
            _ => continue,
        };
    }

    subscribe_to_program();

    let cors = rocket_cors::CorsOptions::default().to_cors()?;

    rocket::build()
        .mount("/", routes![index, get_all_stream])
        .attach(cors)
        .launch()
        .await?;

    Ok(())
}
```

在 main 函数中，我们正在获取所有的程序帐户并填充我们的数据库，然后我们可以调用`subscribe_to_program`函数。在这之后，我们将启动火箭服务器。

你可以在这里看到完整的后端[。](https://github.com/SushantChandla/sol-stream-backend)

# 前端

现在让我们来编写应用程序的前端部分。我已经为前端创建了一个 React 应用程序，使用 Redux 进行状态管理。我已经创建了它的 UI 部分，你可以在这里找到。

您可以克隆并检出`ui`分支，并在以下命令的帮助下运行它:

```
yarn
yarn start 
```

运行后，您可以在浏览器中看到用户界面:

{ % embed URL = "[https://youtu.be/r9CwLIR4afY](https://youtu.be/r9CwLIR4afY)" caption = " UI Sample " % }

现在让我们编写与 sol-stream-program 连接的函数。

在`src/actions/index.js`中:

```
import {
  SystemProgram,
  Transaction,
  PublicKey,
  TransactionInstruction,
  Connection,
} from "@solana/web3.js";

import axios from "../config";
import { deserialize, serialize } from "borsh";

const programAccount = new PublicKey(
  "DcGPfiGbubEKh1EnQ86EdMvitjhrUo8fGSgvqtFG4A9t"
);

const adminAddress = new PublicKey(
  "DGqXoguiJnAy8ExJe9NuZpWrnQMCV14SdEdiMEdCfpmB"
);

const cluster = "https://api.devnet.solana.com";
const connection = new Connection(cluster, "confirmed");
```

我们已经创建了`programAccount`和`adminAddress`变量来存储程序的程序 id 和管理地址。在包含 devnet RPC 链接的`cluster`变量的帮助下，我们还创建了一个`connection`变量。

现在让我们先写`getAllStreams`函数，你可以在`action/index.js`文件的最后找到它。它只是包含了一个对我们后端客户端的请求，它将`pubkey`的字符串值作为参数。我已经使用了 axios 包，我们可以在`src/config/index.js`中更改基本 URL:

```
import axios from "axios";

export default axios.create({
  baseURL: "http://127.0.0.1:8000",
});
```

既然我们的`baseURL`已经设置好了，我们可以在`src/actions/index.js`中编写函数，更新`getAllStreams`函数为:

```
export const getAllStreams = (pubkey) => {
  return async (dispatch, getState) => {
    try {
      let response = await axios.get(`/${pubkey}`);
      console.log(response);
      if (response.status !== 200) throw new Error("Something went wrong");
      dispatch({
        type: "DATA_RECEIVED",
        result: response.data,
      });
    } catch (e) {
      console.log(e);
      dispatch({
        type: "DATA_NOT_RECEIVED",
        result: { data: null },
      });
    }
  };
};
```

我们请求路由“/”，然后发送结果。我们在 try and catch 块中添加了代码来处理网络错误。

## 创建流

现在让我们编写包含程序指令的函数。我们还将为数据序列化创建一个模式。

在`src/actions/index.js`文件中:

```
class CreateStreamInput {
  constructor(properties) {
    Object.keys(properties).forEach((key) => {
      this[key] = properties[key];
    });
  }
  static schema = new Map([
    [
      CreateStreamInput,
      {
        kind: "struct",
        fields: [
          ["start_time", "u64"],
          ["end_time", "u64"],
          ["receiver", [32]],
          ["lamports_withdrawn", "u64"],
          ["amount_second", "u64"],
        ],
      },
    ],
  ]);
}
```

为了创建流指令，我们定义了一个描述变量数据类型的模式。我们将在`createStream`函数中使用它:

```
export const createStream = ({
  receiverAddress,
  startTime,
  endTime,
  amountSpeed,
  wallet
}) => {
  return async (dispatch, getState) => {
    try {
      const SEED = "abcdef" + Math.random().toString();
      let newAccount = await PublicKey.createWithSeed(
        wallet.publicKey,
        SEED,
        programAccount
      );
      let create_stream_input = new CreateStreamInput({
        start_time: startTime,
        end_time: endTime,
        receiver: new PublicKey(receiverAddress).toBuffer(),
        lamports_withdrawn: 0,
        amount_second: amountSpeed,
      });

      let data = serialize(CreateStreamInput.schema, create_stream_input);
```

在上面的代码中，我们创建了一个公钥，我们将使用它来创建一个程序驱动的帐户(PDA)。我们已经使用了 borsh 包中的函数`serialize`来获取输入数据的 Uint8Array。

```
      let data_to_send = new Uint8Array([1, ...data]);
      let rent = await connection.getMinimumBalanceForRentExemption(96);
```

我们必须在 Uint8Array 中追加`1`,因为我们使用第一个字符作为标签。请参考`instructions.rs`中的解包功能。

然后，我们可以通过在连接变量上使用`getMinimumBalanceForRentExemption`函数来获得创建帐户所需的最少端口。

```
      const createProgramAccount = SystemProgram.createAccountWithSeed({
        fromPubkey: wallet.publicKey,
        basePubkey: wallet.publicKey,
        seed: SEED,
        newAccountPubkey: newAccount,
        lamports: ((endTime - startTime) * amountSpeed) + 30000000 + rent,
        space: 96,
        programId: programAccount,
      });

      const instructionTOOurProgram = new TransactionInstruction({
        keys: [
          { pubkey: newAccount, isSigner: false, isWritable: true },
          { pubkey: wallet.publicKey, isSigner: true, },
          { pubkey: receiverAddress, isSigner: false, },
          { pubkey: adminAddress, isSigner: false, isWritable: true }
        ],
        programId: programAccount,
        data: data_to_send
      });
```

在上面的代码中，我们创建了 2 条指令:

1.  创建一个空间为`96`且端口等于`0.03(admin cut)+solana rent+total amount user want to send`的程序驱动账户。我们在`SystemProgram.createAccountWithSeed`函数中传递这些参数。

2.  该指令包含一组与交易相关的公钥，特别是`newAccount`(正在创建的 PDA)、来自签名者连接的钱包的签名者公钥，以及接收者和管理员地址。`programId`是部署的程序地址，`data`是指令数据，包括指定执行哪个指令的标签(CreateStream、WithdrawFromStream 或 CloseStream)。

然后，我们创建一个事务对象，我们使用了稍后将添加的`setPayerAndBlockhashTransaction`函数。一旦我们有了交易对象，我们必须在钱包的帮助下发送交易。我们随后发送了结果。如果出现错误，我们可以提醒用户。

```
      const trans = await setPayerAndBlockhashTransaction(
        [createProgramAccount, instructionTOOurProgram], wallet
      );

      let signature = await wallet.sendTransaction(trans, connection);
      const result = await connection.confirmTransaction(signature);
      console.log("end sendMessage", result);
      dispatch(getAllStreams(wallet.publicKey.toString()));
      dispatch({
        type: "CREATE_RESPONSE",
        result: true,
        id: newAccount.toString(),
      });
    } catch (e) {
      alert(e);
      dispatch({ type: "CREATE_FAILED", result: false });
    }
  };
};
```

`setPayerAndBlockhashTransaction`:这个函数接收指令数组，然后返回一个`Transaction`对象。

```
async function setPayerAndBlockhashTransaction(instructions, wallet) {
  const transaction = new Transaction();
  instructions.forEach(element => {
    transaction.add(element);
  });
  transaction.feePayer = wallet.publicKey;
  let hash = await connection.getRecentBlockhash();
  transaction.recentBlockhash = hash.blockhash;
  return transaction;
}
```

你可以在这里查看`CreateStream`功能[，以供参考。](https://github.com/SushantChandla/sol-stream-frontend/blob/418bcdcd434d6b7e1dc3cd9e9d323066c54a6f0b/src/actions/index.js#L102)

> 注意:我通过这里的测试[检查了数据的大小(值 96)。](https://github.com/SushantChandla/sol-stream-program/blob/d0d537889b155d16fa3c0879e61e4f68c3d47f07/src/state.rs#L42)

## 撤退

现在让我们为这个函数编写`withdraw`函数，我们也创建了带有模式的`WithdrawInput`类:

我们在用于撤销输入的结构中只有`amount`变量。

```
class WithdrawInput {
  constructor(properties) {
    Object.keys(properties).forEach((key) => {
      this[key] = properties[key];
    });
  }
  static schema = new Map([[WithdrawInput,
    {
      kind: 'struct',
      fields: [
        ['amount', 'u64'],
      ]
    }]]);
}
```

这一次我们不创建 PDA，所以我们在这个事务中只有一个指令，它是针对我们的程序的。注意，`streamId`是`PDA`账户的地址。

在这里的`data_to_send`中，我们必须在数组的开头指定 2。如您所知，在我们程序的`instruction.rs`文件中，我们为 WithdrawFromStream 指令设置了标签 2。

```
export const withdraw = (streamId, amountToWithdraw, wallet) => {
  return async (dispatch, getState) => {
    try {
      let create_stream_input = new WithdrawInput({
        amount: amountToWithdraw
      });
      let data = serialize(WithdrawInput.schema, create_stream_input);
      let data_to_send = new Uint8Array([2, ...data]);

      const instructionTOOurProgram = new TransactionInstruction({
        keys: [
          { pubkey: streamId, isSigner: false, isWritable: true },
          { pubkey: wallet.publicKey, isSigner: true, },
        ],
        programId: programAccount,
        data: data_to_send
      });

      const trans = await setPayerAndBlockhashTransaction(
        [instructionTOOurProgram], wallet
      );

      let signature = await wallet.sendTransaction(trans, connection);
      const result = await connection.confirmTransaction(signature);
      console.log("end sendMessage", result);
      dispatch({ type: "WITHDRAW_SUCCESS" });
    } catch (e) {
      alert(e);
      dispatch({ type: "WITHDRAW_FAILED" });
    }
  };
}
```

我们最终发送了撤回结果。你可以在这里查看`Withdraw`功能[，以供参考。](https://github.com/SushantChandla/sol-stream-frontend/blob/418bcdcd434d6b7e1dc3cd9e9d323066c54a6f0b/src/actions/index.js#L23)

## 关闭流

现在让我们编写文件中的最后一个函数来关闭一个流。

对于这个函数，我们没有任何指令数据，我们只传递标签。然后我们通过调用`setPayerAndBlockhashTransaction`打包指令，然后发送结果。

```
export const closeStream = (streamId, receiverAddress, wallet) => {
  return async (dispatch, getState) => {
    try {
      const instructionTOOurProgram = new TransactionInstruction({
        keys: [
          { pubkey: streamId, isSigner: false, isWritable: true },
          { pubkey: wallet.publicKey, isSigner: true, isWritable: true },
          { pubkey: receiverAddress, isSigner: false, isWritable: true }
        ],
        programId: programAccount,
        data: new Uint8Array([3])
      });

      const trans = await setPayerAndBlockhashTransaction(
        [instructionTOOurProgram], wallet
      );

      let signature = await wallet.sendTransaction(trans, connection);
      const result = await connection.confirmTransaction(signature);
      console.log("end sendMessage", result);
      dispatch({ type: "CANCEL_SUCCESS" });
    } catch (e) {
      alert(e);
      dispatch({ type: "CANCEL_FAILED" });
    }
  };
};
```

你可以在这里查看前端代码[。您可以在这里](https://github.com/SushantChandla/sol-stream-frontend)查看`closeStream`功能[，以供参考。](https://github.com/SushantChandla/sol-stream-frontend/blob/418bcdcd434d6b7e1dc3cd9e9d323066c54a6f0b/src/actions/index.js#L72)

现在为了测试它，我们需要运行后端服务器。这里是一个视频演练。

{ % embed URL = "[https://youtu.be/MUyt5Rz9T64](https://youtu.be/MUyt5Rz9T64)" caption = " Sol 流媒体协议" %}

# 结论

在本教程中，您学习了如何在 Solana 上构建 Sol 令牌流协议。我们用 Rust 编程语言介绍了链上程序的代码。我们用 React 构建了用户界面。我们已经创建了一个后端与火箭框架索引 PDA 的数据。

# 关于作者

本教程由 [Sushant Chandla](https://github.com/SushantChandla) 创作。